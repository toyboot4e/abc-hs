#!/usr/bin/env stack
{- stack script --resolver lts-21.6 --package array --package bytestring --package containers --package deepseq --package extra --package hashable --package unordered-containers --package heaps --package mtl --package utility-ht --package vector --package vector-algorithms --package primitive --package QuickCheck --package random --package transformers --ghc-options "-D DEBUG" -}

-- {{{ toy-lib: https://github.com/toyboot4e/toy-lib
{-# OPTIONS_GHC -Wno-unused-imports -Wno-unused-top-binds -Wno-orphans #-}
{- ORMOLU_DISABLE -}
{-# LANGUAGE BlockArguments, CPP, DefaultSignatures, DerivingVia, LambdaCase, MultiWayIf, NumDecimals, PatternSynonyms, QuantifiedConstraints, RecordWildCards, StandaloneDeriving, StrictData, TypeFamilies #-}
import Control.Applicative;import Control.DeepSeq;import Control.Exception (assert);import Control.Monad;import Control.Monad.Fix;import Control.Monad.IO.Class;import Control.Monad.Primitive;import Control.Monad.ST;import Control.Monad.State.Class;import Control.Monad.Trans (MonadTrans, lift);import Control.Monad.Trans.State.Strict (State, StateT, runState, evalState, execState, runStateT, evalStateT, execStateT);import Data.Bifunctor;import Data.Bits;import Data.Bool (bool);import Data.Char;import Data.Coerce;import Data.Either;import Data.Foldable;import Data.Function (on);import Data.Functor;import Data.Functor.Identity;import Data.IORef;import Data.Kind;import Data.List.Extra hiding (nubOn);import Data.Maybe;import Data.Ord;import Data.Primitive.MutVar;import Data.Proxy;import Data.STRef;import Data.Semigroup;import Data.Word;import Debug.Trace;import GHC.Exts;import GHC.Float (int2Float);import GHC.Ix (unsafeIndex);import GHC.Stack (HasCallStack);import System.Exit (exitSuccess);import System.IO;import System.Random;import System.Random.Stateful;import Text.Printf;import qualified Data.Ratio as Ratio;import Data.Array.IArray;import Data.Array.IO;import Data.Array.MArray;import Data.Array.ST;import Data.Array.Unboxed (UArray);import Data.Array.Unsafe;import qualified Data.Array as A;import qualified Data.ByteString.Builder as BSB;import qualified Data.ByteString.Char8 as BS;import qualified Data.ByteString.Unsafe as BSU;import Control.Monad.Extra hiding (loop);import Data.IORef.Extra;import Data.List.Extra hiding (merge);import Data.Tuple.Extra hiding (first, second);import Numeric.Extra;import Data.Bool.HT;import qualified Data.Ix.Enum as HT;import qualified Data.List.HT as HT;import qualified Data.Vector.Fusion.Bundle as FB;import qualified Data.Vector.Generic as G;import qualified Data.Vector.Generic.Mutable as GM;import qualified Data.Vector.Primitive as P;import qualified Data.Vector.Unboxed as U;import qualified Data.Vector.Unboxed.Base as U;import qualified Data.Vector.Unboxed.Mutable as UM;import qualified Data.Vector as V;import qualified Data.Vector.Mutable as VM;import qualified Data.Vector.Fusion.Bundle.Monadic as MB;import qualified Data.Vector.Fusion.Bundle.Size as MB;import qualified Data.Vector.Fusion.Stream.Monadic as MS;import qualified Data.Vector.Algorithms.Merge as VAM;import qualified Data.Vector.Algorithms.Intro as VAI;import qualified Data.Vector.Algorithms.Search as VAS;import qualified Data.IntMap.Strict as IM;import qualified Data.Map.Strict as M;import qualified Data.IntSet as IS;import qualified Data.Set as S;import qualified Data.Sequence as Seq;import qualified Data.Heap as H;import qualified Data.HashMap.Strict as HM;import qualified Data.HashSet as HS;import qualified Test.QuickCheck as QC
{-# RULES "Force inline VAI.sort" VAI.sort = VAI.sortBy compare #-}
#ifdef DEBUG
dbg :: Show a => a -> () ; dbg !x = let !_ = traceShow x () in () ; dbgAssert :: Bool -> String -> () ; dbgAssert False !s = error $ "assertion failed!: " ++ s ; dbgAssert True _ = () ; dbgS :: String -> () ; dbgS !s = let !_ = trace s () in () ; dbgId :: Show a => a -> a ; dbgId !x = let !_ = traceShow x () in x ; note :: (Show s, Show a) => s -> a -> a ; note !s !x = let !_ = trace (show s ++ ": " ++ show x) () in x ;
#else
dbg :: Show a => a -> () ; dbg _ = () ; dbgAssert :: Bool -> a -> a ; dbgAssert = flip const ; dbgS :: String -> () ; dbgS _ = () ; dbgId :: Show a => a -> a ; dbgId = id ; note :: (Show s, Show a) => s -> a -> a ; note _ !x = x ;
#endif
type SparseUnionFind = IM.IntMap Int;newSUF :: SparseUnionFind;newSUF = IM.empty;memberSUF :: Int -> SparseUnionFind -> Bool;memberSUF = IM.member;insertSUF :: Int -> SparseUnionFind -> SparseUnionFind;insertSUF !x !uf = IM.insert x (-1) uf;fromListSUF :: [(Int, Int)] -> SparseUnionFind;fromListSUF = foldl' (\ uf (!i, !j) -> unifySUF i j uf) newSUF;fromVecSUF :: U.Vector (Int, Int) -> SparseUnionFind;fromVecSUF = U.foldl' (\ uf (!i, !j) -> unifySUF i j uf) newSUF;rootSUF :: (HasCallStack) => Int -> SparseUnionFind -> (Int, Int);rootSUF !i !uf | IM.notMember i uf = (i, 1) | j < 0 = (i, -j) | otherwise = rootSUF j uf where { j = uf IM.! i};sameSUF :: (HasCallStack) => Int -> Int -> SparseUnionFind -> Bool;sameSUF !i !j !uf = fst (rootSUF i uf) == fst (rootSUF j uf);unifySUF :: (HasCallStack) => Int -> Int -> SparseUnionFind -> SparseUnionFind;unifySUF !i !j !uf | a == b = uf | r >= s = IM.insert a (negate $! r + s) $ IM.insert b a uf | otherwise = IM.insert b (negate $! r + s) $ IM.insert a b uf where { (!a, !r) = rootSUF i uf; (!b, !s) = rootSUF j uf};newtype MUnionFind s = MUnionFind (UM.MVector s MUFNode);type IOUnionFind = MUnionFind RealWorld;type STUnionFind s = MUnionFind s;data MUFNode = MUFChild {-# UNPACK #-} !Int | MUFRoot {-# UNPACK #-} !Int deriving (Eq, Show);instance U.IsoUnbox MUFNode (Bool, Int) where { {-# INLINE toURepr #-}; toURepr (MUFChild !x) = (True, x); toURepr (MUFRoot !x) = (False, x); {-# INLINE fromURepr #-}; fromURepr (True, !x) = MUFChild x; fromURepr (False, !x) = MUFRoot x};newtype instance  U.MVector s MUFNode = MV_MUFNode (UM.MVector s (Bool, Int));newtype instance  U.Vector MUFNode = V_MUFNode (U.Vector (Bool, Int));deriving via (MUFNode `U.As` (Bool, Int)) instance GM.MVector UM.MVector MUFNode;deriving via (MUFNode `U.As` (Bool, Int)) instance G.Vector U.Vector MUFNode;instance U.Unbox MUFNode;{-# INLINE newMUF #-};newMUF :: (PrimMonad m) => Int -> m (MUnionFind (PrimState m));newMUF !n = MUnionFind <$> UM.replicate n (MUFRoot 1);{-# INLINE rootMUF #-};rootMUF :: (HasCallStack, PrimMonad m) => MUnionFind (PrimState m) -> Int -> m Int;rootMUF uf@(MUnionFind !vec) i = do { !node <- UM.unsafeRead vec i; case node of { MUFRoot _ -> return i; MUFChild p -> do { !r <- rootMUF uf p; UM.unsafeWrite vec i (MUFChild r); return r}}};{-# INLINE groupsMUF #-};groupsMUF :: (HasCallStack, PrimMonad m) => MUnionFind (PrimState m) -> m IS.IntSet;groupsMUF uf@(MUnionFind !vec) = foldM step IS.empty [0 .. pred (GM.length vec)] where { step !is !i = do { !root <- rootMUF uf i; return $ IS.insert root is}};{-# INLINE sameMUF #-};sameMUF :: (HasCallStack, PrimMonad m) => MUnionFind (PrimState m) -> Int -> Int -> m Bool;sameMUF !uf !x !y = liftM2 (==) (rootMUF uf x) (rootMUF uf y);_unwrapMUFRoot :: MUFNode -> Int;_unwrapMUFRoot (MUFRoot !s) = s; _unwrapMUFRoot (MUFChild !_) = error "tried to unwrap child as UF root";{-# INLINE unifyMUF #-};unifyMUF :: (HasCallStack, PrimMonad m) => MUnionFind (PrimState m) -> Int -> Int -> m Bool;unifyMUF uf@(MUnionFind !vec) !x !y = do { !px <- rootMUF uf x; !py <- rootMUF uf y; when (px /= py) $ do { !sx <- _unwrapMUFRoot <$> UM.unsafeRead vec px; !sy <- _unwrapMUFRoot <$> UM.unsafeRead vec py; let { (!par, !chld) = if sx < sy then (px, py) else (py, px)}; UM.unsafeWrite vec chld (MUFChild par); UM.unsafeWrite vec par (MUFRoot $! sx + sy)}; return $ px /= py};{-# INLINE unifyMUF_ #-};unifyMUF_ :: (HasCallStack, PrimMonad m) => MUnionFind (PrimState m) -> Int -> Int -> m ();unifyMUF_ uf x y = void $ unifyMUF uf x y;{-# INLINE sizeMUF #-};sizeMUF :: (HasCallStack, PrimMonad m) => MUnionFind (PrimState m) -> Int -> m Int;sizeMUF uf@(MUnionFind !vec) !x = do { !px <- rootMUF uf x; _unwrapMUFRoot <$> UM.unsafeRead vec px};{-# INLINE clearMUF #-};clearMUF :: (PrimMonad m) => MUnionFind (PrimState m) -> m ();clearMUF (MUnionFind !vec) = do { UM.set vec (MUFRoot 1)};data PUnionFind s = DUnionFind{nodesPUF :: UM.MVector s MUFNode, potencialPUF :: UM.MVector s Int};newPUF :: (PrimMonad m) => Int -> m (PUnionFind (PrimState m));newPUF n = DUnionFind <$> UM.replicate n (MUFRoot 1) <*> UM.replicate n (0 :: Int);rootPUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> m Int;rootPUF uf = inner where { inner v = UM.read (nodesPUF uf) v >>= \case { MUFRoot _ -> return v; MUFChild p -> do { !r <- inner p; when (p /= r) $ do { !pp <- UM.read (potencialPUF uf) p; UM.write (nodesPUF uf) v (MUFChild r); UM.modify (potencialPUF uf) (pp +) v}; return r}}};unifyPUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> Int -> Int -> m Bool;unifyPUF !uf !v1 !v2 !dp = do { !r1 <- rootPUF uf v1; !r2 <- rootPUF uf v2; if r1 == r2 then return False else do { !size1 <- UM.read (potencialPUF uf) v1; !size2 <- UM.read (potencialPUF uf) v2; if size1 < size2 then unifyPUF uf v2 v1 (-dp) else do { !sz1 <- _unwrapMUFRoot <$> UM.read (nodesPUF uf) r1; !sz2 <- _unwrapMUFRoot <$> UM.read (nodesPUF uf) r2; UM.write (nodesPUF uf) r1 (MUFRoot (sz1 + sz2)); !p1 <- UM.read (potencialPUF uf) v1; !p2 <- UM.read (potencialPUF uf) v2; let { !pr2 = p1 - p2 - dp}; UM.write (nodesPUF uf) r2 (MUFChild r1); UM.write (potencialPUF uf) r2 pr2; return True}}};sizePUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> m Int;sizePUF !uf !v = fmap _unwrapMUFRoot . UM.read (nodesPUF uf) =<< rootPUF uf v;samePUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> Int -> m Bool;samePUF !uf !v1 !v2 = (==) <$> rootPUF uf v1 <*> rootPUF uf v2;canUnifyPUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> Int -> Int -> m Bool;canUnifyPUF !uf !v1 !v2 !d = do { !r1 <- rootPUF uf v1; !r2 <- rootPUF uf v2; !p1 <- UM.read (potencialPUF uf) v1; !p2 <- UM.read (potencialPUF uf) v2; return $ r1 /= r2 || p1 - p2 == d};potPUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> m Int;potPUF !uf !v1 = do { void $ rootPUF uf v1; UM.read (potencialPUF uf) v1};diffPUF :: (PrimMonad m) => PUnionFind (PrimState m) -> Int -> Int -> m Int;diffPUF !uf !v1 !v2 = (-) <$> potPUF uf v1 <*> potPUF uf v2;clearPUF :: (PrimMonad m) => PUnionFind (PrimState m) -> m ();clearPUF !uf = do { UM.set (potencialPUF uf) (0 :: Int); UM.set (nodesPUF uf) (MUFRoot 1)};data SegmentTree v s a = SegmentTree (a -> a -> a) (v s a);{-# INLINE newSTreeG #-};newSTreeG :: (GM.MVector v a, PrimMonad m) => (a -> a -> a) -> Int -> a -> m (SegmentTree v (PrimState m) a);newSTreeG !f !nLeaves !zero = SegmentTree f <$> GM.replicate nVerts zero where { !nVerts = until (>= 2 * nLeaves) (* 2) 2};{-# INLINE newSTreeV #-};newSTreeV :: (PrimMonad m) => (a -> a -> a) -> Int -> a -> m (SegmentTree VM.MVector (PrimState m) a);newSTreeV = newSTreeG;{-# INLINE newSTreeU #-};newSTreeU :: (U.Unbox a, PrimMonad m) => (a -> a -> a) -> Int -> a -> m (SegmentTree UM.MVector (PrimState m) a);newSTreeU = newSTreeG;resetSTree :: (GM.MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> a -> m ();resetSTree (SegmentTree !_ !vec) !zero = GM.set vec zero;{-# INLINE insertSTree #-};insertSTree :: (GM.MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> Int -> a -> m ();insertSTree tree@(SegmentTree !_ !vec) !i !value = _updateElement tree i' value where { !offset = GM.length vec `div` 2 - 1; !i' = i + offset};{-# INLINE modifySTree #-};modifySTree :: (GM.MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> (a -> a) -> Int -> m ();modifySTree tree@(SegmentTree !_ !vec) !f !i = do { !v <- f <$> GM.unsafeRead vec i'; _updateElement tree i' v} where { !offset = GM.length vec `div` 2 - 1; !i' = i + offset};_updateElement :: (HasCallStack, GM.MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> Int -> a -> m ();_updateElement (SegmentTree !_ !vec) 0 !value = do { GM.unsafeWrite vec 0 value}; _updateElement tree@(SegmentTree !f !vec) !i !value = do { GM.unsafeWrite vec i value; case (i - 1) `div` 2 of { (-1) -> return (); !iParent -> do { !c1 <- GM.unsafeRead vec $! iParent * 2 + 1; !c2 <- GM.unsafeRead vec $! iParent * 2 + 2; _updateElement tree iParent $! f c1 c2}}};{-# INLINE querySTree #-};querySTree :: forall v a m . (HasCallStack, GM.MVector v a, PrimMonad m) => SegmentTree v (PrimState m) a -> Int -> Int -> m (Maybe a);querySTree (SegmentTree !f !vec) !lo !hi | lo > hi = return Nothing | lo < 0 || hi >= (GM.length vec `div` 2) = return Nothing | otherwise = inner 0 0 initialHi where { !initialHi = GM.length vec `div` 2 - 1; inner :: Int -> Int -> Int -> m (Maybe a); inner !i !l !h | lo <= l && h <= hi = Just <$> GM.unsafeRead vec i | h < lo || hi < l = return Nothing | otherwise = do { let { !d = (h - l) `div` 2}; !ansL <- inner (2 * i + 1) l (l + d); !ansH <- inner (2 * i + 2) (l + d + 1) h; pure . Just $ case (ansL, ansH) of { (Just !a, Just !b) -> f a b; (Just !a, _) -> a; (_, Just !b) -> b; (_, _) -> error $ "query error (segment tree): " ++ show (i, (l, h), (lo, hi))}}};class SemigroupAction s a where { sact :: s -> a -> a};class (SemigroupAction m a, Monoid m) => MonoidAction m a where { mact :: m -> a -> a; mact = sact};instance SemigroupAction (Product Int) Int where { sact (Product !x1) !x2 = x1 * x2};newtype Permutation = Permutation (U.Vector Int) deriving (Show, Eq);instance Semigroup Permutation where { (Permutation vec1) <> (Permutation vec2) = Permutation $! U.map (vec1 U.!) vec2 where { !_ = dbgAssert (G.length vec1 == G.length vec2)}};instance SemigroupAction Permutation Int where { sact (Permutation !vec) !i = vec U.! i};data LazySegmentTree v a op s = LazySegmentTree !(v s a) !(UM.MVector s op) !Int;newLazySTree :: forall v a op m . (GM.MVector v a, Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => Int -> m (LazySegmentTree v a op (PrimState m));newLazySTree !n = do { !as <- GM.replicate n2 mempty; !ops <- UM.replicate n2 mempty; return $ LazySegmentTree as ops h} where { (!h, !n2) = until ((>= 2 * n) . snd) (bimap succ (* 2)) (0 :: Int, 1 :: Int)};newLazySTreeV :: forall a op m . (Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => Int -> m (LazySegmentTree VM.MVector a op (PrimState m));newLazySTreeV = newLazySTree;newLazySTreeU :: forall a op m . (U.Unbox a, Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => Int -> m (LazySegmentTree UM.MVector a op (PrimState m));newLazySTreeU = newLazySTree;generateLazySTreeG :: forall v a op m . (HasCallStack, GM.MVector v a, Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => Int -> (Int -> a) -> m (LazySegmentTree v a op (PrimState m));generateLazySTreeG !n !f = do { !as <- GM.unsafeNew n2; forM_ [1 .. nLeaves] $ \ i -> do { if i <= n then GM.write as (nLeaves + i - 1) $! f (pred i) else GM.write as (nLeaves + i - 1) mempty}; forM_ [nLeaves - 1, nLeaves - 2 .. 1] $ \ i -> do { !l <- GM.read as (childL i); !r <- GM.read as (childR i); GM.write as i (l <> r)}; !ops <- UM.replicate n2 mempty; return $ LazySegmentTree as ops h} where { (!h, !n2) = until ((>= 2 * n) . snd) (bimap succ (* 2)) (0 :: Int, 1 :: Int); !nLeaves = n2 `div` 2; childL !vertex = shiftL vertex 1; childR !vertex = shiftL vertex 1 .|. 1};generateLazySTreeV :: forall a op m . (HasCallStack, Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => Int -> (Int -> a) -> m (LazySegmentTree VM.MVector a op (PrimState m));generateLazySTreeV = generateLazySTreeG;generateLazySTreeU :: forall a op m . (HasCallStack, U.Unbox a, Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => Int -> (Int -> a) -> m (LazySegmentTree UM.MVector a op (PrimState m));generateLazySTreeU = generateLazySTreeG;updateLazySTree :: forall v a op m . (GM.MVector v a, Monoid a, MonoidAction op a, Eq op, U.Unbox op, PrimMonad m) => LazySegmentTree v a op (PrimState m) -> Int -> Int -> op -> m ();updateLazySTree stree@(LazySegmentTree !_ !ops !_) !iLLeaf !iRLeaf !op = do { let { !_ = dbgAssert (inRange (0, nLeaves - 1) iLLeaf && inRange (0, nLeaves - 1) iRLeaf) $ "updateLazySTree: wrong range " ++ show (iLLeaf, iRLeaf)}; _propOpMonoidsToLeaf stree iLLeaf; _propOpMonoidsToLeaf stree iRLeaf; let { !lVertex = iLLeaf + nLeaves; !rVertex = iRLeaf + nLeaves}; glitchLoopUpdate lVertex rVertex; _evalToRoot stree iLLeaf; _evalToRoot stree iRLeaf; return ()} where { !nLeaves = UM.length ops `div` 2; isLeftChild = not . (`testBit` 0); isRightChild = (`testBit` 0); glitchLoopUpdate :: Int -> Int -> m (); glitchLoopUpdate !l !r | l > r = return () | otherwise = do { !l' <- if isRightChild l then do { UM.modify ops (<> op) l; return $ succ l} else return l; !r' <- if isLeftChild r then do { UM.modify ops (<> op) r; return $ pred r} else return r; glitchLoopUpdate (shiftR l' 1) (shiftR r' 1)}};queryLazySTree :: forall v a m op . (HasCallStack, GM.MVector v a, Monoid a, MonoidAction op a, Eq op, U.Unbox op, PrimMonad m) => LazySegmentTree v a op (PrimState m) -> Int -> Int -> m a;queryLazySTree stree@(LazySegmentTree !as !ops !_) !iLLeaf !iRLeaf = do { let { !_ = dbgAssert (inRange (0, nLeaves - 1) iLLeaf && inRange (0, nLeaves - 1) iRLeaf) $ "queryLazySTree: wrong range " ++ show (iLLeaf, iRLeaf)}; _propOpMonoidsToLeaf stree iLLeaf; _propOpMonoidsToLeaf stree iRLeaf; let { !lVertex = iLLeaf + nLeaves; !rVertex = iRLeaf + nLeaves}; glitchLoopQuery lVertex rVertex mempty mempty} where { !nLeaves = GM.length as `div` 2; isLeftChild = not . (`testBit` 0); isRightChild = (`testBit` 0); glitchLoopQuery :: Int -> Int -> a -> a -> m a; glitchLoopQuery !l !r !lAcc !rAcc | l > r = return $! lAcc <> rAcc | otherwise = do { (!l', !lAcc') <- if isRightChild l then do { !la' <- mact <$!> UM.read ops l <*> GM.read as l; return (succ l, lAcc <> la')} else return (l, lAcc); (!r', !rAcc') <- if isLeftChild r then do { !ra' <- mact <$!> UM.read ops r <*> GM.read as r; return (pred r, ra' <> rAcc)} else return (r, rAcc); glitchLoopQuery (shiftR l' 1) (shiftR r' 1) lAcc' rAcc'}};_propOpMonoidsToLeaf :: (HasCallStack, GM.MVector v a, MonoidAction op a, Eq op, U.Unbox op, PrimMonad m) => LazySegmentTree v a op (PrimState m) -> Int -> m ();_propOpMonoidsToLeaf (LazySegmentTree !as !ops !height) !iLeaf = do { let { !leafVertex = iLeaf + nVerts `div` 2}; forM_ [height - 1, height - 2 .. 1] $ \ iParent -> do { let { !vertex = nthParent leafVertex iParent}; !op <- UM.read ops vertex; when (op /= mempty) $ do { UM.modify ops (<> op) $! childL vertex; UM.modify ops (<> op) $! childR vertex; GM.modify as (mact op) vertex; UM.write ops vertex mempty}}} where { !nVerts = GM.length as; nthParent !leafVertex !nth = shiftR leafVertex nth; childL !vertex = shiftL vertex 1; childR !vertex = shiftL vertex 1 .|. 1};_evalToRoot :: (HasCallStack, GM.MVector v a, Monoid a, MonoidAction op a, U.Unbox op, PrimMonad m) => LazySegmentTree v a op (PrimState m) -> Int -> m ();_evalToRoot (LazySegmentTree !as !ops !height) !iLeaf = do { let { !leafVertex = iLeaf + nVerts `div` 2}; forM_ [1 .. pred height] $ \ iParent -> do { let { !vertex = nthParent leafVertex iParent}; let { !_ = dbgAssert (vertex > 0) "_evalToRoot"}; !aL' <- mact <$> UM.read ops (childL vertex) <*> GM.read as (childL vertex); !aR' <- mact <$> UM.read ops (childR vertex) <*> GM.read as (childR vertex); GM.write as vertex $! aL' <> aR'}} where { !nVerts = GM.length as; nthParent !leafVertex !nth = shiftR leafVertex nth; childL !vertex = shiftL vertex 1; childR !vertex = shiftL vertex 1 .|. 1};class Semiring s where { (<+>) :: s -> s -> s; szero :: s; (<.>) :: s -> s -> s; sone :: s};foldP :: (Semiring a, G.Vector v a) => v a -> a;foldP = G.foldl' (<+>) szero;foldT :: (Semiring a, G.Vector v a) => v a -> a;foldT = G.foldl' (<.>) sone;newtype MaxPlus a = MaxPlus{getMaxPlus :: a} deriving (P.Prim)                                             deriving newtype (Eq, Ord, Show);newtype instance  U.MVector s (MaxPlus a) = MV_MaxPlus (P.MVector s (MaxPlus a));newtype instance  U.Vector (MaxPlus a) = V_MaxPlus (P.Vector (MaxPlus a));deriving via (U.UnboxViaPrim (MaxPlus a)) instance (P.Prim a) => GM.MVector UM.MVector (MaxPlus a);deriving via (U.UnboxViaPrim (MaxPlus a)) instance (P.Prim a) => G.Vector U.Vector (MaxPlus a);instance (P.Prim a) => U.Unbox (MaxPlus a);instance (Num a, Bounded a, Ord a) => Semiring (MaxPlus a) where { {-# INLINE (<+>) #-}; (MaxPlus x1) <+> (MaxPlus x2) = MaxPlus (x1 `max` x2); {-# INLINE szero #-}; szero = MaxPlus minBound; {-# INLINE (<.>) #-}; (MaxPlus x1) <.> (MaxPlus x2) = MaxPlus (x1 + x2); {-# INLINE sone #-}; sone = MaxPlus 0};newtype MinPlus a = MinPlus{getMinPlus :: a} deriving (P.Prim)                                             deriving newtype (Eq, Ord, Show);newtype instance  U.MVector s (MinPlus a) = MV_MinPlus (P.MVector s (MinPlus a));newtype instance  U.Vector (MinPlus a) = V_MinPlus (P.Vector (MinPlus a));deriving via (U.UnboxViaPrim (MinPlus a)) instance (P.Prim a) => GM.MVector UM.MVector (MinPlus a);deriving via (U.UnboxViaPrim (MinPlus a)) instance (P.Prim a) => G.Vector U.Vector (MinPlus a);instance (P.Prim a) => U.Unbox (MinPlus a);instance (Num a, Bounded a, Ord a) => Semiring (MinPlus a) where { {-# INLINE (<+>) #-}; (MinPlus x1) <+> (MinPlus x2) = MinPlus (x1 `min` x2); {-# INLINE szero #-}; szero = MinPlus maxBound; {-# INLINE (<.>) #-}; (MinPlus x1) <.> (MinPlus x2) = MinPlus (x1 + x2); {-# INLINE sone #-}; sone = MinPlus 0};newtype Boolean = Boolean{getBoolean :: Bool} deriving newtype (Eq, Ord, Show);instance U.IsoUnbox Boolean Bool where { {-# INLINE toURepr #-}; toURepr (Boolean b) = b; {-# INLINE fromURepr #-}; fromURepr = Boolean};newtype instance  U.MVector s Boolean = MV_Foo (U.MVector s Bool);newtype instance  U.Vector Boolean = V_Foo (U.Vector Bool);deriving via (Boolean `U.As` Bool) instance GM.MVector UM.MVector Boolean;deriving via (Boolean `U.As` Bool) instance G.Vector U.Vector Boolean;instance U.Unbox Boolean;instance Semiring Boolean where { {-# INLINE (<+>) #-}; (Boolean x1) <+> (Boolean x2) = Boolean (x1 || x2); {-# INLINE szero #-}; szero = Boolean False; {-# INLINE (<.>) #-}; (Boolean x1) <.> (Boolean x2) = Boolean (x1 && x2); {-# INLINE sone #-}; sone = Boolean True};class (Ix i, U.Unbox i) => Unindex i where { unindex :: (i, i) -> Int -> i};instance Unindex Int where { unindex _ !v = v};instance Unindex (Int, Int) where { unindex ((!y0, !x0), (!_, !x1)) !yx = let { !w = x1 - x0 + 1; (!dy, !dx) = yx `quotRem` w} in (y0 + dy, x0 + dx)};instance Unindex (Int, Int, Int) where { unindex ((!z0, !y0, !x0), (!_, !y1, !x1)) !zyx = let { !h = y1 - y0 + 1; !w = x1 - x0 + 1; (!dz, !yx) = zyx `quotRem` (h * w); (!dy, !dx) = yx `quotRem` w} in (z0 + dz, y0 + dy, x0 + dx)};instance Unindex (Int, Int, Int, Int) where { unindex ((!b3, !b2, !b1, !b0), (!_, !x2, !x1, !x0)) !pos3 = let { !w2 = x2 - b2 + 1; !w1 = x1 - b1 + 1; !w0 = x0 - b0 + 1; (!y3, !pos2) = pos3 `quotRem` (w2 * w1 * w0); (!y2, !pos1) = pos2 `quotRem` (w1 * w0); (!y1, !y0) = pos1 `quotRem` w0} in (b3 + y3, b2 + y2, b1 + y1, b0 + y0)};instance Unindex ((Int, Int), (Int, Int)) where { unindex (((!b3, !b2), (!b1, !b0)), ((!_, !x2), (!x1, !x0))) !pos3 = let { !w2 = x2 - b2 + 1; !w1 = x1 - b1 + 1; !w0 = x0 - b0 + 1; (!y3, !pos2) = pos3 `quotRem` (w2 * w1 * w0); (!y2, !pos1) = pos2 `quotRem` (w1 * w0); (!y1, !y0) = pos1 `quotRem` w0} in ((b3 + y3, b2 + y2), (b1 + y1, b0 + y0))};type Vertex = Int;type EdgeId = Int;type CapacityMCF c = c;type FlowMCF c = c;type CostMCF c = c;data MinCostFlow s c = MinCostFlow{nVertsMCF :: !Int, nEdgesMCF :: !Int, offsetsMCF :: !(U.Vector Int), edgeDstMCF :: !(U.Vector Int), edgeRevIndexMCF :: !(U.Vector Int), edgeCapMCF :: !(UM.MVector s (CapacityMCF c)), edgeCostMCF :: !(U.Vector (CostMCF c))};data MinCostFlowBuffer r s c = MinCostFlowBuffer{distsMCF :: !(UM.MVector s r), prevVertMCF :: !(UM.MVector s Vertex), prevEdgeMCF :: !(UM.MVector s EdgeId)};relaxedCostFlow' :: (Show (f (CostMCF c)), Num (f (CostMCF c)), Monoid (f (CostMCF c)), U.Unbox (f (CostMCF c)), Ord (f (CostMCF c)), Num (f (CostMCF c)), PrimMonad m, Show c, Num c, U.Unbox c, Integral c, Ord c, Bounded c) => (CostMCF c -> f (CostMCF c)) -> Int -> Int -> Int -> CapacityMCF c -> U.Vector (Vertex, Vertex, CapacityMCF c, CostMCF c) -> m (Maybe (f (CostMCF c)), MinCostFlow (PrimState m) c);relaxedCostFlow' toRelax !nVerts !src !sink !targetFlow !edges = do { !container <- buildMinCostFlow nVerts edges; !minCost <- runMinCostFlow toRelax src sink targetFlow container; return (minCost, container)};relaxedCostFlow :: (Show (f (CostMCF c)), Num (f (CostMCF c)), Monoid (f (CostMCF c)), U.Unbox (f (CostMCF c)), Ord (f (CostMCF c)), Num (f (CostMCF c)), Show c, Num c, U.Unbox c, Integral c, Ord c, Bounded c) => (CostMCF c -> f (CostMCF c)) -> Int -> Int -> Int -> CapacityMCF c -> U.Vector (Vertex, Vertex, CapacityMCF c, CostMCF c) -> Maybe (f (CostMCF c));relaxedCostFlow toRelax !nVerts !src !sink !targetFlow !edges = runST $ do { fst <$> relaxedCostFlow' toRelax nVerts src sink targetFlow edges};minCostFlow :: (Show c, Num c, U.Unbox c, Integral c, Ord c, Bounded c) => Int -> Int -> Int -> CapacityMCF c -> U.Vector (Vertex, Vertex, CapacityMCF c, CostMCF c) -> Maybe (Min (CostMCF c));minCostFlow = relaxedCostFlow Min;minCostFlow' :: (PrimMonad m, Show c, Num c, U.Unbox c, Integral c, Ord c, Bounded c) => Int -> Int -> Int -> CapacityMCF c -> U.Vector (Vertex, Vertex, CapacityMCF c, CostMCF c) -> m (Maybe (Min (CostMCF c)), MinCostFlow (PrimState m) c);minCostFlow' = relaxedCostFlow' Min;maxCostFlow :: (Show c, Num c, U.Unbox c, Integral c, Ord c, Bounded c) => Int -> Int -> Int -> CapacityMCF c -> U.Vector (Vertex, Vertex, CapacityMCF c, CostMCF c) -> Maybe (Max (CostMCF c));maxCostFlow = relaxedCostFlow Max;maxCostFlow' :: (PrimMonad m, Show c, Num c, U.Unbox c, Integral c, Ord c, Bounded c) => Int -> Int -> Int -> CapacityMCF c -> U.Vector (Vertex, Vertex, CapacityMCF c, CostMCF c) -> m (Maybe (Max (CostMCF c)), MinCostFlow (PrimState m) c);maxCostFlow' = relaxedCostFlow' Max;edgesMCF :: (PrimMonad m, Show c, Num c, U.Unbox c, Integral c, Ord c, Bounded c) => MinCostFlow (PrimState m) c -> m (U.Vector (Int, Int, CapacityMCF c, FlowMCF c, CostMCF c));edgesMCF MinCostFlow{..} = do { !edgeCap <- U.unsafeFreeze edgeCapMCF; let { next (!i12, !v1) | i12 == offsetsMCF U.! (v1 + 1) = next (i12, v1 + 1) | otherwise = ((v1, v2, cap, flow, cost), (i12 + 1, v1)) where { v2 = edgeDstMCF U.! i12; i21 = edgeRevIndexMCF U.! i12; flow = edgeCap U.! i21; cap = edgeCap U.! i12 + edgeCap U.! i21; cost = edgeCostMCF U.! i12}}; return $ U.unfoldrExactN nEdgesMCF next (0 :: EdgeId, 0 :: Vertex)};undefMCF :: Int;undefMCF = -1;buildMinCostFlow :: forall c m . (PrimMonad m, Show c, Num c, U.Unbox c, Integral c, Ord c, Bounded c) => Int -> U.Vector (Vertex, Vertex, CapacityMCF c, CostMCF c) -> m (MinCostFlow (PrimState m) c);buildMinCostFlow !nVertsMCF !edges = do { let { !offsetsMCF = U.scanl' (+) (0 :: Int) $ U.create $ do { !degs <- UM.replicate nVertsMCF (0 :: Int); G.forM_ edges $ \ (!v1, !v2, !_, !_) -> do { GM.modify degs (+ 1) v1; GM.modify degs (+ 1) v2}; return degs}}; (!edgeDstMCF, !edgeRevIndexMCF, !edgeCostMCF, !edgeCapMCF) <- do { !edgeDst <- UM.replicate nEdgesMCF undefMCF; !edgeRevIndex <- UM.replicate nEdgesMCF undefMCF; !edgeCost <- UM.replicate nEdgesMCF (0 :: CostMCF c); !edgeCap <- UM.replicate nEdgesMCF (0 :: CapacityMCF c); !edgeCounter <- U.thaw offsetsMCF; G.forM_ edges $ \ (!v1, !v2, !cap, !cost) -> do { let { !_ = dbgAssert (cost >= 0) $ "costs must be zero or positive" ++ show (v1, v2)}; let { !_ = dbgAssert (v1 /= v2) $ "cannot use self loop edge: " ++ show (v1, v2)}; !i1 <- GM.read edgeCounter v1; !i2 <- GM.read edgeCounter v2; GM.modify edgeCounter (+ 1) v1; GM.modify edgeCounter (+ 1) v2; GM.write edgeRevIndex i1 i2; GM.write edgeRevIndex i2 i1; GM.write edgeDst i1 v2; GM.write edgeDst i2 v1; GM.write edgeCap i1 cap; GM.write edgeCost i1 cost; GM.write edgeCost i2 (-cost)}; (, , , edgeCap) <$> G.unsafeFreeze edgeDst <*> G.unsafeFreeze edgeRevIndex <*> G.unsafeFreeze edgeCost}; return MinCostFlow{..}} where { !nEdgesMCF = G.length edges * 2};runMinCostFlow :: forall f c m . (Show (f (CostMCF c)), Num (f (CostMCF c)), Monoid (f (CostMCF c)), U.Unbox (f (CostMCF c)), Ord (f (CostMCF c)), Num (f (CostMCF c)), PrimMonad m, Show c, Num c, U.Unbox c, Integral c, Ord c, Bounded c) => (CostMCF c -> f (CostMCF c)) -> Vertex -> Vertex -> FlowMCF c -> MinCostFlow (PrimState m) c -> m (Maybe (f (CostMCF c)));runMinCostFlow !toRelax !src !sink !targetFlow container@MinCostFlow{..} = do { bufs@MinCostFlowBuffer{..} <- MinCostFlowBuffer <$> UM.unsafeNew nVertsMCF <*> UM.unsafeNew nVertsMCF <*> UM.unsafeNew nVertsMCF; let { run !accCost !restFlow | restFlow <= 0 = let { !_ = dbgAssert (restFlow == 0) "flew too much?"} in return $ Just accCost | otherwise = do { GM.set distsMCF mempty; GM.set prevVertMCF undefMCF; GM.set prevEdgeMCF undefMCF; let { !_ = dbg ("short")}; runMinCostFlowShortests toRelax src container bufs; let { !_ = dbg ("let's DFS")}; !distSink <- UM.read distsMCF sink; if distSink == mempty then do { let { !_ = dbg ("failure")}; return Nothing} else do { !deltaFlow <- flip fix (restFlow, sink) $ \ loop (!flow, !v2) -> do { if v2 == src then return flow else do { !v1 <- UM.read prevVertMCF v2; !i12 <- UM.read prevEdgeMCF v2; let { !_ = dbg ("read", v1, v2, i12)}; !cap12 <- UM.read edgeCapMCF i12; loop (min flow cap12, v1)}}; let { !_ = dbg (deltaFlow)}; let { !_ = dbgAssert (deltaFlow >= 0) $ "negative delta flow?"}; let { accCost' = accCost + toRelax deltaFlow * distSink}; let { restFlow' = restFlow - deltaFlow}; flip fix sink $ \ loop v2 -> do { if v2 == src then return () else do { !v1 <- UM.read prevVertMCF v2; !i12 <- UM.read prevEdgeMCF v2; let { !i21 = edgeRevIndexMCF U.! i12}; UM.modify edgeCapMCF (subtract deltaFlow) i12; UM.modify edgeCapMCF (+ deltaFlow) i21; loop v1}}; run accCost' restFlow'}}}; run (toRelax 0) targetFlow};runMinCostFlowShortests :: (Show (f (CostMCF c)), U.Unbox (f (CostMCF c)), Monoid (f (CostMCF c)), Ord (f (CostMCF c)), Num (f (CostMCF c)), Show c, U.Unbox c, Num c, Ord c, Bounded c, PrimMonad m) => (CostMCF c -> f (CostMCF c)) -> Vertex -> MinCostFlow (PrimState m) c -> MinCostFlowBuffer (f (CostMCF c)) (PrimState m) c -> m ();runMinCostFlowShortests !toRelax !src MinCostFlow{..} MinCostFlowBuffer{..} = do { UM.write distsMCF src (toRelax 0); fix $ \ loop -> do { !b <- (\ f -> U.foldM' f False (U.generate nVertsMCF id)) $ \ !anyUpdate v1 -> do { !d1 <- UM.read distsMCF v1; if d1 == mempty then do { return anyUpdate} else do { let { !iStart = offsetsMCF U.! v1; !iEnd = offsetsMCF U.! (v1 + 1)}; (\ f -> U.foldM' f anyUpdate (U.generate (iEnd - iStart) (+ iStart))) $ \ !anyUpdate i12 -> do { let { !v2 = edgeDstMCF U.! i12}; !cap12 <- UM.read edgeCapMCF i12; let { !cost12 = edgeCostMCF U.! i12}; !d2 <- UM.read distsMCF v2; let { d2' = d1 + toRelax cost12}; let { !_ = dbg ((v1, v2), (d1, d2, d2'), d2 /= d2' && (d2 <> d2' == d2'))}; if cap12 > 0 && d2 /= d2' && (d2 <> d2' == d2') then do { UM.write distsMCF v2 d2'; UM.write prevVertMCF v2 v1; UM.write prevEdgeMCF v2 i12; return True} else do { return anyUpdate}}}}; when b $ do { loop}}};zeroBnd1 :: Int -> (Int, Int);zeroBnd1 w = (0, w - 1);zeroBnd2 :: (Int, Int) -> ((Int, Int), (Int, Int));zeroBnd2 (!h, !w) = ((0, 0), (h - 1, w - 1));zeroBnd3 :: (Int, Int, Int) -> ((Int, Int, Int), (Int, Int, Int));zeroBnd3 (!d, !h, !w) = ((0, 0, 0), (d - 1, h - 1, w - 1));data IxVector i v = IxVector{boundsIV :: !(i, i), vecIV :: !v} deriving (Show, Eq);type IxUVector i a = IxVector i (U.Vector a);type IxMUVector s i a = IxVector i (UM.MVector s a);{-# INLINE (@!) #-};(@!) :: (HasCallStack, Ix i, G.Vector v a) => IxVector i (v a) -> i -> a;(@!) IxVector{..} i = vecIV G.! index boundsIV i;{-# INLINE (@!!) #-};(@!!) :: (Ix i, G.Vector v a) => IxVector i (v a) -> i -> a;(@!!) IxVector{..} i = G.unsafeIndex vecIV (unsafeIndex boundsIV i);{-# INLINE (@!?) #-};(@!?) :: (HasCallStack, Ix i, G.Vector v a) => IxVector i (v a) -> i -> Maybe a;(@!?) IxVector{..} i | inRange boundsIV i = Just (vecIV G.! index boundsIV i) | otherwise = Nothing;{-# INLINE (@!!?) #-};(@!!?) :: (Ix i, G.Vector v a) => IxVector i (v a) -> i -> Maybe a;(@!!?) IxVector{..} i | inRange boundsIV i = Just (G.unsafeIndex vecIV (unsafeIndex boundsIV i)) | otherwise = Nothing;{-# INLINE mapIV #-};mapIV :: (U.Unbox a, U.Unbox b) => (a -> b) -> IxVector i (U.Vector a) -> IxVector i (U.Vector b);mapIV !f !vec = IxVector bnd $ U.map f (vecIV vec) where { !bnd = boundsIV vec};{-# INLINE imapIV #-};imapIV :: (Unindex i, U.Unbox a, U.Unbox b) => (i -> a -> b) -> IxVector i (U.Vector a) -> IxVector i (U.Vector b);imapIV !f !vec = IxVector bnd $ U.imap wrapper (vecIV vec) where { !bnd = boundsIV vec; wrapper i = f (unindex bnd i)};{-# INLINE zipWithIV #-};zipWithIV :: (U.Unbox a, U.Unbox b, U.Unbox c) => (a -> b -> c) -> IxVector i (U.Vector a) -> IxVector i (U.Vector b) -> IxVector i (U.Vector c);zipWithIV !f !vec1 !vec2 = IxVector bnd $ U.zipWith f (vecIV vec1) (vecIV vec2) where { !bnd = boundsIV vec1};{-# INLINE accumulateIV #-};accumulateIV :: (Ix i, U.Unbox i, U.Unbox a, U.Unbox b) => (a -> b -> a) -> IxVector i (U.Vector a) -> IxVector i (U.Vector (i, b)) -> IxVector i (U.Vector a);accumulateIV !f !vec0 !commands = let { !input1d = U.map (first (index bnd)) (vecIV commands); !vec1d = U.accumulate f (vecIV vec0) input1d} in IxVector bnd vec1d where { !bnd = boundsIV vec0; !_ = dbgAssert (boundsIV vec0 == boundsIV commands)};{-# INLINE createIV #-};createIV :: (G.Vector v a) => (forall s . ST s (IxVector i (G.Mutable v s a))) -> IxVector i (v a);createIV st = runST $ do { iv <- st; let { bnd = boundsIV iv}; IxVector bnd <$> G.unsafeFreeze (vecIV iv)};{-# INLINE generateIV #-};generateIV :: (Unindex i, U.Unbox a) => (i, i) -> (i -> a) -> IxUVector i a;generateIV bnd f = IxVector bnd $ U.generate (rangeSize bnd) (f . unindex bnd);{-# INLINE constructIV #-};constructIV :: (Unindex i, U.Unbox a) => (i, i) -> (IxUVector i a -> i -> a) -> IxUVector i a;constructIV bnd f = IxVector bnd $ U.constructN (rangeSize bnd) $ \ sofar -> f (IxVector bnd sofar) $! unindex bnd (G.length sofar);{-# INLINE thawIV #-};thawIV :: (PrimMonad m, G.Vector v a) => IxVector i (v a) -> m (IxVector i (G.Mutable v (PrimState m) a));thawIV iv = IxVector (boundsIV iv) <$> G.thaw (vecIV iv);{-# INLINE unsafeThawIV #-};unsafeThawIV :: (PrimMonad m, G.Vector v a) => IxVector i (v a) -> m (IxVector i (G.Mutable v (PrimState m) a));unsafeThawIV iv = IxVector (boundsIV iv) <$> G.thaw (vecIV iv);{-# INLINE freezeIV #-};freezeIV :: (PrimMonad m, G.Vector v a) => IxVector i (G.Mutable v (PrimState m) a) -> m (IxVector i (v a));freezeIV iv = IxVector (boundsIV iv) <$> G.freeze (vecIV iv);{-# INLINE unsafeFreezeIV #-};unsafeFreezeIV :: (PrimMonad m, G.Vector v a) => IxVector i (G.Mutable v (PrimState m) a) -> m (IxVector i (v a));unsafeFreezeIV iv = IxVector (boundsIV iv) <$> G.unsafeFreeze (vecIV iv);{-# INLINE csum2D #-};csum2D :: (HasCallStack, Num a, U.Unbox a) => IxUVector (Int, Int) a -> IxUVector (Int, Int) a;csum2D !gr = IxVector bnd $ U.constructN (rangeSize bnd) $ \ sofar -> case unindex bnd (G.length sofar) of { (0, _) -> 0; (_, 0) -> 0; (!y, !x) -> v0 + fromY + fromX - fromD where { v0 = gr @! (y - 1, x - 1); fromY = IxVector bnd sofar @! (y - 1, x); fromX = IxVector bnd sofar @! (y, x - 1); fromD = IxVector bnd sofar @! (y - 1, x - 1)}} where { !bnd = second (both (+ 1)) (boundsIV gr)};{-# INLINE (@+!) #-};(@+!) :: (HasCallStack, Num a, U.Unbox a) => IxUVector (Int, Int) a -> ((Int, Int), (Int, Int)) -> a;(@+!) !csum ((!y1, !x1), (!y2, !x2)) = s1 + s4 - s2 - s3 where { !s1 = csum @! (y2 + 1, x2 + 1); !s2 = csum @! (y1, x2 + 1); !s3 = csum @! (y2 + 1, x1); !s4 = csum @! (y1, x1)};{-# INLINE readIV #-};readIV :: (HasCallStack, Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> m a;readIV IxVector{..} i = GM.read vecIV (index boundsIV i);{-# INLINE readMayIV #-};readMayIV :: (HasCallStack, Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> m (Maybe a);readMayIV IxVector{..} i | not (inRange boundsIV i) = return Nothing | otherwise = Just <$> GM.read vecIV (index boundsIV i);{-# INLINE unsafeReadIV #-};unsafeReadIV :: (Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> m a;unsafeReadIV IxVector{..} i = GM.unsafeRead vecIV (unsafeIndex boundsIV i);{-# INLINE writeIV #-};writeIV :: (HasCallStack, Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> a -> m ();writeIV IxVector{..} i = GM.write vecIV (index boundsIV i);{-# INLINE unsafeWriteIV #-};unsafeWriteIV :: (Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> a -> m ();unsafeWriteIV IxVector{..} i = GM.unsafeWrite vecIV (unsafeIndex boundsIV i);{-# INLINE modifyIV #-};modifyIV :: (HasCallStack, Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> (a -> a) -> i -> m ();modifyIV IxVector{..} !alter i = GM.modify vecIV alter (index boundsIV i);{-# INLINE unsafeModifyIV #-};unsafeModifyIV :: (Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> (a -> a) -> i -> m ();unsafeModifyIV IxVector{..} !alter i = GM.unsafeModify vecIV alter (unsafeIndex boundsIV i);{-# INLINE modifyMIV #-};modifyMIV :: (HasCallStack, Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> (a -> m a) -> i -> m ();modifyMIV IxVector{..} !alter i = GM.modifyM vecIV alter (index boundsIV i);{-# INLINE unsafeModifyMIV #-};unsafeModifyMIV :: (Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> (a -> m a) -> i -> m ();unsafeModifyMIV IxVector{..} !alter i = GM.unsafeModifyM vecIV alter (unsafeIndex boundsIV i);{-# INLINE swapIV #-};swapIV :: (HasCallStack, Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> i -> m ();swapIV IxVector{..} !i1 !i2 = GM.swap vecIV (index boundsIV i1) (index boundsIV i2);{-# INLINE unsafeSwapIV #-};unsafeSwapIV :: (Ix i, PrimMonad m, GM.MVector v a) => IxVector i (v (PrimState m) a) -> i -> i -> m ();unsafeSwapIV IxVector{..} !i1 !i2 = GM.unsafeSwap vecIV (unsafeIndex boundsIV i1) (unsafeIndex boundsIV i2);imos2DIV :: (HasCallStack) => IxVector (Int, Int) (U.Vector Int) -> IxVector (Int, Int) (U.Vector Int);imos2DIV seeds@IxVector{boundsIV} = IxVector boundsIV $ U.create $ do { !vec <- IxVector boundsIV <$> U.thaw (vecIV seeds); let { (!minY, !minX) = fst boundsIV}; forM_ (range boundsIV) $ \ (!y, !x) -> do { !v <- if x == minX then return 0 else readIV vec (y, x - 1); modifyIV vec (+ v) (y, x)}; forM_ (range boundsIV) $ \ (!x, !y) -> do { !v <- if y == minY then return 0 else readIV vec (y - 1, x); modifyIV vec (+ v) (y, x)}; return $ vecIV vec};{-# INLINE constructNM #-};constructNM :: forall a m . (PrimMonad m, U.Unbox a) => Int -> (U.Vector a -> m a) -> m (U.Vector a);constructNM !n f = do { v <- GM.new n; v' <- G.unsafeFreeze v; fill v' 0} where { fill :: U.Vector a -> Int -> m (U.Vector a); fill !v i | i < n = do { x <- f (G.unsafeTake i v); G.elemseq v x $ do { v' <- G.unsafeThaw v; GM.unsafeWrite v' i x; v'' <- G.unsafeFreeze v'; fill v'' (i + 1)}}; fill v _ = return v};{-# INLINE constructrNM #-};constructrNM :: forall a m . (PrimMonad m, U.Unbox a) => Int -> (U.Vector a -> m a) -> m (U.Vector a);constructrNM !n f = do { v <- n `seq` GM.new n; v' <- G.unsafeFreeze v; fill v' 0} where { fill :: U.Vector a -> Int -> m (U.Vector a); fill !v i | i < n = do { x <- f (G.unsafeSlice (n - i) i v); G.elemseq v x $ do { v' <- G.unsafeThaw v; GM.unsafeWrite v' (n - i - 1) x; v'' <- G.unsafeFreeze v'; fill v'' (i + 1)}}; fill v _ = return v};{-# INLINE csum1D #-};csum1D :: (Num a, U.Unbox a) => U.Vector a -> U.Vector a;csum1D = U.scanl' (+) 0;{-# INLINE (+!) #-};(+!) :: (Num a, U.Unbox a) => U.Vector a -> (Int, Int) -> a;(+!) csum (!l, !r) = csum U.! succ r - csum U.! l;type SizedList = (Int, [Int]);compareSL :: SizedList -> SizedList -> Ordering;compareSL (!len1, !xs1) (!len2, !xs2) | len1 > len2 = GT | len1 < len2 = LT | otherwise = inner xs1 xs2 where { inner [] [] = EQ; inner (y1 : ys1) (y2 : ys2) = case compare y1 y2 of { EQ -> inner ys1 ys2; c -> c}; inner _ [] = error "unreachable: `compareSL`"; inner [] _ = error "unreachable: `compareSL`"};maxSL :: SizedList -> SizedList -> SizedList;maxSL sl1 sl2 = case compareSL sl1 sl2 of { GT -> sl1; _ -> sl2};nullSL :: SizedList -> Bool;nullSL = null . snd;emptySL :: SizedList;emptySL = (0, []);consSL :: SizedList -> Int -> SizedList;consSL (!len, !xs) !x = (len + 1, x : xs);class SafeList v where { type SafeListElem v; headMay :: v -> Maybe (SafeListElem v); lastMay :: v -> Maybe (SafeListElem v); headOr :: SafeListElem v -> v -> SafeListElem v; lastOr :: SafeListElem v -> v -> SafeListElem v; minimumMay :: v -> Maybe (SafeListElem v); maximumMay :: v -> Maybe (SafeListElem v); minimumOr :: SafeListElem v -> v -> SafeListElem v; maximumOr :: SafeListElem v -> v -> SafeListElem v};instance (Ord a) => SafeList [a] where { type SafeListElem [a] = a; headMay [] = Nothing; headMay (x : _) = Just x; lastMay [] = Nothing; lastMay xs = Just $ last xs; headOr x0 [] = x0; headOr _ xs = head xs; lastOr x0 [] = x0; lastOr _ xs = last xs; minimumMay [] = Nothing; minimumMay xs = Just $ minimum xs; maximumMay [] = Nothing; maximumMay xs = Just $ maximum xs; minimumOr x0 [] = x0; minimumOr _ xs = minimum xs; maximumOr x0 [] = x0; maximumOr _ xs = maximum xs};instance (Ord a) => SafeList (V.Vector a) where { type SafeListElem (V.Vector a) = a; headMay xs | G.null xs = Nothing | otherwise = Just $ G.unsafeHead xs; lastMay xs | G.null xs = Nothing | otherwise = Just $ G.unsafeLast xs; headOr x0 xs | G.null xs = x0 | otherwise = G.unsafeHead xs; lastOr x0 xs | G.null xs = x0 | otherwise = G.unsafeLast xs; minimumMay xs | G.null xs = Nothing | otherwise = Just $ G.minimum xs; maximumMay xs | G.null xs = Nothing | otherwise = Just $ G.maximum xs; minimumOr x0 xs | G.null xs = x0 | otherwise = G.minimum xs; maximumOr x0 xs | G.null xs = x0 | otherwise = G.maximum xs};instance (U.Unbox a, Ord a) => SafeList (U.Vector a) where { type SafeListElem (U.Vector a) = a; headMay xs | G.null xs = Nothing | otherwise = Just $ G.unsafeHead xs; lastMay xs | G.null xs = Nothing | otherwise = Just $ G.unsafeLast xs; headOr x0 xs | G.null xs = x0 | otherwise = G.unsafeHead xs; lastOr x0 xs | G.null xs = x0 | otherwise = G.unsafeLast xs; minimumMay xs | G.null xs = Nothing | otherwise = Just $ G.minimum xs; maximumMay xs | G.null xs = Nothing | otherwise = Just $ G.maximum xs; minimumOr x0 xs | G.null xs = x0 | otherwise = G.minimum xs; maximumOr x0 xs | G.null xs = x0 | otherwise = G.maximum xs};data BinaryHeap (f :: Type -> Type) s a = BinaryHeap{priorityBH :: !(a -> f a), intVarsBH :: !(UM.MVector s Int), internalVecBH :: !(UM.MVector s a)};_sizeBH :: Int;_sizeBH = 0;{-# INLINE _sizeBH #-};type MinBinaryHeap s a = BinaryHeap Identity s a;type MaxBinaryHeap s a = BinaryHeap Down s a;newBinaryHeap :: (U.Unbox a, PrimMonad m) => (a -> f a) -> Int -> m (BinaryHeap f (PrimState m) a);newBinaryHeap prio n = BinaryHeap prio <$> UM.replicate 1 0 <*> UM.unsafeNew n;newMinBinaryHeap :: (U.Unbox a, PrimMonad m) => Int -> m (MinBinaryHeap (PrimState m) a);newMinBinaryHeap = newBinaryHeap Identity;newMaxBinaryHeap :: (U.Unbox a, PrimMonad m) => Int -> m (MaxBinaryHeap (PrimState m) a);newMaxBinaryHeap = newBinaryHeap Down;getBinaryHeapSize :: (PrimMonad m) => BinaryHeap f (PrimState m) a -> m Int;getBinaryHeapSize BinaryHeap{..} = UM.unsafeRead intVarsBH _sizeBH;{-# INLINE getBinaryHeapSize #-};siftUpBy :: (U.Unbox a, PrimMonad m) => (a -> a -> Ordering) -> Int -> UM.MVector (PrimState m) a -> m ();siftUpBy cmp k vec = do { x <- UM.unsafeRead vec k; flip fix k $ \ loop !i -> if i > 0 then do { let { parent = (i - 1) `unsafeShiftR` 1}; p <- UM.unsafeRead vec parent; case cmp p x of { GT -> UM.unsafeWrite vec i p >> loop parent; _ -> UM.unsafeWrite vec i x}} else UM.unsafeWrite vec 0 x};{-# INLINE siftUpBy #-};siftDownBy :: (U.Unbox a, PrimMonad m) => (a -> a -> Ordering) -> Int -> UM.MVector (PrimState m) a -> m ();siftDownBy cmp k vec = do { x <- UM.unsafeRead vec k; let { !n = UM.length vec}; flip fix k $ \ loop !i -> do { let { l = unsafeShiftL i 1 .|. 1}; let { r = l + 1}; if n <= l then UM.unsafeWrite vec i x else do { vl <- UM.unsafeRead vec l; if r < n then do { vr <- UM.unsafeRead vec r; case cmp vr vl of { LT -> case cmp x vr of { GT -> UM.unsafeWrite vec i vr >> loop r; _ -> UM.unsafeWrite vec i x}; _ -> case cmp x vl of { GT -> UM.unsafeWrite vec i vl >> loop l; _ -> UM.unsafeWrite vec i x}}} else case cmp x vl of { GT -> UM.unsafeWrite vec i vl >> loop l; _ -> UM.unsafeWrite vec i x}}}};{-# INLINE siftDownBy #-};heapifyBy :: (U.Unbox a, PrimMonad m) => (a -> a -> Ordering) -> UM.MVector (PrimState m) a -> m ();heapifyBy cmp vec = do { let { n = UM.length vec `quot` 2}; forM_ [n - 1, n - 2 .. 0] $ \ i -> do { siftDownBy cmp i vec}};{-# INLINE heapifyBy #-};class OrdVia f a where { compareVia :: (a -> f a) -> a -> a -> Ordering};instance (Ord a) => OrdVia Identity a where { compareVia _ = coerce (compare :: Identity a -> Identity a -> Ordering); {-# INLINE compareVia #-}};instance (Ord a) => OrdVia Down a where { compareVia _ = coerce (compare :: Down a -> Down a -> Ordering); {-# INLINE compareVia #-}};buildBinaryHeapVia :: (OrdVia f a, U.Unbox a, PrimMonad m) => (a -> f a) -> U.Vector a -> m (BinaryHeap f (PrimState m) a);buildBinaryHeapVia priorityBH vec = do { intVarsBH <- UM.replicate 1 $ U.length vec; internalVecBH <- U.thaw vec; heapifyBy (compareVia priorityBH) internalVecBH; return $! BinaryHeap{..}};{-# INLINE buildBinaryHeapVia #-};buildMinBinaryHeap :: (Ord a, U.Unbox a, PrimMonad m) => U.Vector a -> m (BinaryHeap Identity (PrimState m) a);buildMinBinaryHeap = buildBinaryHeapVia Identity;{-# INLINE buildMinBinaryHeap #-};buildMaxBinaryHeap :: (Ord a, U.Unbox a, PrimMonad m) => U.Vector a -> m (BinaryHeap Down (PrimState m) a);buildMaxBinaryHeap = buildBinaryHeapVia Down;{-# INLINE buildMaxBinaryHeap #-};unsafeViewBH :: (U.Unbox a, PrimMonad m) => BinaryHeap f (PrimState m) a -> m a;unsafeViewBH BinaryHeap{..} = UM.unsafeRead internalVecBH 0;{-# INLINE unsafeViewBH #-};viewBH :: (U.Unbox a, PrimMonad m) => BinaryHeap f (PrimState m) a -> m (Maybe a);viewBH bh = do { size <- getBinaryHeapSize bh; if size > 0 then Just <$!> unsafeViewBH bh else return Nothing};{-# INLINE viewBH #-};insertBH :: (OrdVia f a, U.Unbox a, PrimMonad m) => BinaryHeap f (PrimState m) a -> a -> m ();insertBH BinaryHeap{..} x = do { size <- UM.unsafeRead intVarsBH _sizeBH; UM.unsafeWrite intVarsBH _sizeBH (size + 1); UM.unsafeWrite internalVecBH size x; siftUpBy (compareVia priorityBH) size internalVecBH};{-# INLINE insertBH #-};unsafeDeleteBH :: (OrdVia f a, U.Unbox a, PrimMonad m) => BinaryHeap f (PrimState m) a -> m ();unsafeDeleteBH BinaryHeap{..} = do { size' <- subtract 1 <$!> UM.unsafeRead intVarsBH _sizeBH; UM.unsafeWrite intVarsBH _sizeBH size'; UM.unsafeSwap internalVecBH 0 size'; siftDownBy (compareVia priorityBH) 0 (UM.unsafeTake size' internalVecBH)};{-# INLINE unsafeDeleteBH #-};modifyTopBH :: (OrdVia f a, U.Unbox a, PrimMonad m) => BinaryHeap f (PrimState m) a -> (a -> a) -> m ();modifyTopBH BinaryHeap{..} f = do { UM.unsafeModify internalVecBH f 0; size <- UM.unsafeRead intVarsBH _sizeBH; siftDownBy (compareVia priorityBH) 0 (UM.unsafeTake size internalVecBH)};{-# INLINE modifyTopBH #-};deleteFindTopBH :: (OrdVia f a, U.Unbox a, PrimMonad m) => BinaryHeap f (PrimState m) a -> m (Maybe a);deleteFindTopBH bh = do { size <- getBinaryHeapSize bh; if size > 0 then do { !top <- unsafeViewBH bh <* unsafeDeleteBH bh; return $ Just top} else return Nothing};{-# INLINE deleteFindTopBH #-};clearBH :: (PrimMonad m) => BinaryHeap f (PrimState m) a -> m ();clearBH BinaryHeap{..} = UM.unsafeWrite intVarsBH 0 0;freezeInternalVecBH :: (U.Unbox a, PrimMonad m) => BinaryHeap f (PrimState m) a -> m (U.Vector a);freezeInternalVecBH BinaryHeap{..} = do { size <- UM.unsafeRead intVarsBH _sizeBH; U.unsafeFreeze (UM.unsafeTake size internalVecBH)};type MultiSet = (Int, IM.IntMap Int);emptyMS :: MultiSet;emptyMS = (0, IM.empty);singletonMS :: Int -> MultiSet;singletonMS !x = (1, IM.singleton x 1);fromListMS :: [Int] -> MultiSet;fromListMS = foldl' (flip incMS) emptyMS;incMS :: Int -> MultiSet -> MultiSet;incMS !k (!n, !im) = if IM.member k im then (n, IM.insertWith (+) k 1 im) else (n + 1, IM.insert k 1 im);decMS :: Int -> MultiSet -> MultiSet;decMS !k (!n, !im) = case IM.lookup k im of { Just 1 -> (n - 1, IM.delete k im); Just _ -> (n, IM.insertWith (+) k (-1) im); Nothing -> (n, im)};memberMS :: Int -> MultiSet -> Bool;memberMS !k (!_, !im) = IM.member k im;notMemberMS :: Int -> MultiSet -> Bool;notMemberMS !k (!_, !im) = IM.notMember k im;deleteFindMinMS :: MultiSet -> (Int, MultiSet);deleteFindMinMS ms@(!_, !im) = let { !key = fst $ IM.findMin im} in (key, decMS key ms);innerMS :: MultiSet -> IM.IntMap Int;innerMS (!_, !im) = im;class FromVec a where { type FromVecInput a; type FromVecItem a; fromVec :: (G.Vector v (FromVecInput a)) => v (FromVecInput a) -> a; fromVecWith :: (G.Vector v (FromVecInput a)) => (FromVecItem a -> FromVecItem a -> FromVecItem a) -> v (FromVecInput a) -> a; fromVecWith _ = fromVec};instance FromVec (IM.IntMap a) where { type FromVecInput (IM.IntMap a) = (Int, a); type FromVecItem (IM.IntMap a) = a; fromVec = G.foldl' (\ im (!k, !v) -> IM.insert k v im) IM.empty; fromVecWith !f = G.foldl' (\ im (!k, !v) -> IM.insertWith f k v im) IM.empty};instance (Ord k) => FromVec (M.Map k a) where { type FromVecInput (M.Map k a) = (k, a); type FromVecItem (M.Map k a) = a; fromVec = G.foldl' (\ im (!k, !v) -> M.insert k v im) M.empty; fromVecWith !f = G.foldl' (\ im (!k, !v) -> M.insertWith f k v im) M.empty};instance FromVec IS.IntSet where { type FromVecInput IS.IntSet = Int; type FromVecItem IS.IntSet = Int; fromVec = G.foldl' (flip IS.insert) IS.empty; fromVecWith _ = fromVec};instance (Ord a) => FromVec (S.Set a) where { type FromVecInput (S.Set a) = a; type FromVecItem (S.Set a) = a; fromVec = G.foldl' (flip S.insert) S.empty; fromVecWith _ = fromVec};instance (Ord a) => FromVec (H.Heap a) where { type FromVecInput (H.Heap a) = a; type FromVecItem (H.Heap a) = a; fromVec = G.foldl' (flip H.insert) H.empty; fromVecWith _ = fromVec};instance FromVec MultiSet where { type FromVecInput MultiSet = Int; type FromVecItem MultiSet = Int; fromVec = G.foldl' (flip incMS) emptyMS; fromVecWith _ = fromVec};fromVecIM :: (G.Vector v (Int, a)) => v (Int, a) -> IM.IntMap a;fromVecIM = fromVec;fromVecWithIM :: (G.Vector v (Int, a)) => (a -> a -> a) -> v (Int, a) -> IM.IntMap a;fromVecWithIM = fromVecWith;fromVecM :: (G.Vector v (k, a), Ord k) => v (k, a) -> M.Map k a;fromVecM = fromVec;fromVecWithM :: (G.Vector v (k, a), Ord k) => (a -> a -> a) -> v (k, a) -> M.Map k a;fromVecWithM = fromVecWith;fromVecIS :: (G.Vector v Int) => v Int -> IS.IntSet;fromVecIS = fromVec;fromVecS :: (Ord a, G.Vector v a) => v a -> S.Set a;fromVecS = fromVec;fromVecH :: (Ord a, G.Vector v a) => v a -> H.Heap a;fromVecH = fromVec;data MultiSetVec s = MultiSetVec (MutVar s Int) (UM.MVector s Int);showMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m String;showMSV (MultiSetVec !nRef !mVec) = do { !n <- readMutVar nRef; !vec <- G.unsafeFreeze mVec; return $ show (n, vec)};newMSV :: (PrimMonad m) => Int -> m (MultiSetVec (PrimState m));newMSV !capacity = MultiSetVec <$> newMutVar (0 :: Int) <*> UM.replicate capacity (0 :: Int);clearMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m ();clearMSV (MultiSetVec !nRef !mVec) = do { writeMutVar nRef 0; GM.set mVec 0};fromVecMSV :: (PrimMonad m) => Int -> U.Vector Int -> m (MultiSetVec (PrimState m));fromVecMSV !capacity !xs = do { !msv <- newMSV capacity; U.forM_ xs (incMSV msv); return msv};countMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m Int;countMSV (MultiSetVec !nRef !_) = readMutVar nRef;nullMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m Bool;nullMSV = fmap (== 0) . countMSV;readMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> Int -> m Int;readMSV (MultiSetVec !_ !mVec) = GM.read mVec;incMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> Int -> m ();incMSV (MultiSetVec !nRef !mVec) k = GM.read mVec k >>= \case { 0 -> do { modifyMutVar' nRef succ; GM.write mVec k 1}; !nk -> do { GM.write mVec k (nk + 1)}};decMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> Int -> m ();decMSV (MultiSetVec !nRef !mVec) k = GM.read mVec k >>= \case { 0 -> return (); 1 -> do { modifyMutVar' nRef pred; GM.write mVec k 0}; !nk -> do { GM.write mVec k (nk - 1)}};minMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m (Maybe (Int, Int));minMSV (MultiSetVec !nRef !mVec) = readMutVar nRef >>= \case { 0 -> return Nothing; _ -> do { !vec <- G.unsafeFreeze mVec; return . fmap (\ i -> (i, vec G.! i)) $ G.findIndex (> 0) vec}};maxMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m (Maybe (Int, Int));maxMSV (MultiSetVec !nRef !mVec) = readMutVar nRef >>= \case { 0 -> return Nothing; _ -> do { !vec <- G.unsafeFreeze mVec; return . fmap (\ i -> (i, vec G.! i)) $ G.findIndexR (> 0) vec}};unsafeFreezeMSV :: (PrimMonad m) => MultiSetVec (PrimState m) -> m (Int, U.Vector Int);unsafeFreezeMSV (MultiSetVec !nRef !mVec) = (,) <$> readMutVar nRef <*> U.unsafeFreeze mVec;;data Buffer s a = Buffer{bufferVars :: !(UM.MVector s Int), internalBuffer :: !(UM.MVector s a), internalBufferSize :: !Int};_bufferFrontPos :: Int;_bufferFrontPos = 0;_bufferBackPos :: Int;_bufferBackPos = 1;newBuffer :: (U.Unbox a, PrimMonad m) => Int -> m (Buffer (PrimState m) a);newBuffer n = Buffer <$> UM.replicate 2 0 <*> UM.unsafeNew n <*> pure n;type Stack s a = Buffer s a;newBufferAsStack :: (U.Unbox a, PrimMonad m) => Int -> m (Buffer (PrimState m) a);newBufferAsStack n = Buffer <$> UM.replicate 2 0 <*> UM.unsafeNew n <*> pure n;type Queue s a = Buffer s a;newBufferAsQueue :: (U.Unbox a, PrimMonad m) => Int -> m (Buffer (PrimState m) a);newBufferAsQueue n = Buffer <$> UM.replicate 2 0 <*> UM.unsafeNew n <*> pure n;type Deque s a = Buffer s a;newBufferAsDeque :: (U.Unbox a, PrimMonad m) => Int -> m (Buffer (PrimState m) a);newBufferAsDeque n = Buffer <$> UM.replicate 2 n <*> UM.unsafeNew (2 * n) <*> pure (2 * n);lengthBuffer :: (PrimMonad m) => Buffer (PrimState m) a -> m Int;lengthBuffer Buffer{bufferVars} = liftA2 (-) (UM.unsafeRead bufferVars _bufferBackPos) (UM.unsafeRead bufferVars _bufferFrontPos);{-# INLINE lengthBuffer #-};nullBuffer :: (PrimMonad m) => Buffer (PrimState m) a -> m Bool;nullBuffer = fmap (== 0) . lengthBuffer;{-# INLINE nullBuffer #-};clearBuffer :: (PrimMonad m) => Buffer (PrimState m) a -> m ();clearBuffer Buffer{bufferVars} = do { UM.unsafeWrite bufferVars _bufferFrontPos 0; UM.unsafeWrite bufferVars _bufferBackPos 0};freezeBuffer :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (U.Vector a);freezeBuffer Buffer{bufferVars, internalBuffer} = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; b <- UM.unsafeRead bufferVars _bufferBackPos; U.freeze $ UM.unsafeSlice f (b - f) internalBuffer};unsafeFreezeBuffer :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (U.Vector a);unsafeFreezeBuffer Buffer{bufferVars, internalBuffer} = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; b <- UM.unsafeRead bufferVars _bufferBackPos; U.unsafeFreeze $ UM.unsafeSlice f (b - f) internalBuffer};freezeInternalBuffer :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (U.Vector a);freezeInternalBuffer Buffer{bufferVars, internalBuffer} = do { b <- UM.unsafeRead bufferVars _bufferBackPos; U.freeze $ UM.unsafeSlice 0 b internalBuffer};unsafeFreezeInternalBuffer :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (U.Vector a);unsafeFreezeInternalBuffer Buffer{bufferVars, internalBuffer} = do { b <- UM.unsafeRead bufferVars _bufferBackPos; U.unsafeFreeze $ UM.unsafeSlice 0 b internalBuffer};popFront :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Maybe a);popFront Buffer{bufferVars, internalBuffer} = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; b <- UM.unsafeRead bufferVars _bufferBackPos; if f < b then do { UM.unsafeWrite bufferVars _bufferFrontPos (f + 1); pure <$> UM.unsafeRead internalBuffer f} else return Nothing};{-# INLINE popFront #-};popFront_ :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m ();popFront_ = void . popFront;{-# INLINE popFront_ #-};viewFront :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Maybe a);viewFront Buffer{bufferVars, internalBuffer} = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; b <- UM.unsafeRead bufferVars _bufferBackPos; if f < b then pure <$> UM.unsafeRead internalBuffer f else return Nothing};{-# INLINE viewFront #-};popBack :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Maybe a);popBack Buffer{bufferVars, internalBuffer} = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; b <- UM.unsafeRead bufferVars _bufferBackPos; if f < b then do { UM.unsafeWrite bufferVars _bufferBackPos (b - 1); pure <$> UM.unsafeRead internalBuffer (b - 1)} else return Nothing};{-# INLINE popBack #-};popBack_ :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m ();popBack_ = void . popBack;{-# INLINE popBack_ #-};viewBack :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> m (Maybe a);viewBack Buffer{bufferVars, internalBuffer} = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; b <- UM.unsafeRead bufferVars _bufferBackPos; if f < b then pure <$> UM.unsafeRead internalBuffer (b - 1) else return Nothing};{-# INLINE viewBack #-};pushFront :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> a -> m ();pushFront Buffer{bufferVars, internalBuffer} x = do { f <- UM.unsafeRead bufferVars _bufferFrontPos; UM.unsafeWrite bufferVars _bufferFrontPos (f - 1); assert (f > 0) $ do { UM.unsafeWrite internalBuffer (f - 1) x}};{-# INLINE pushFront #-};pushBack :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> a -> m ();pushBack Buffer{bufferVars, internalBuffer, internalBufferSize} x = do { b <- UM.unsafeRead bufferVars _bufferBackPos; UM.unsafeWrite bufferVars _bufferBackPos (b + 1); assert (b < internalBufferSize) $ do { UM.unsafeWrite internalBuffer b x}};{-# INLINE pushBack #-};pushFronts :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> U.Vector a -> m ();pushFronts Buffer{bufferVars, internalBuffer} vec = do { let { n = U.length vec}; f <- UM.unsafeRead bufferVars _bufferFrontPos; UM.unsafeWrite bufferVars _bufferFrontPos (f - n); assert (n <= f) $ do { U.unsafeCopy (UM.unsafeSlice (f - n) n internalBuffer) vec}};{-# INLINE pushFronts #-};pushBacks :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> U.Vector a -> m ();pushBacks Buffer{bufferVars, internalBuffer, internalBufferSize} vec = do { let { n = U.length vec}; b <- UM.unsafeRead bufferVars _bufferBackPos; UM.unsafeWrite bufferVars _bufferBackPos (b + n); assert (b + n - 1 < internalBufferSize) $ do { U.unsafeCopy (UM.unsafeSlice b n internalBuffer) vec}};{-# INLINE pushBacks #-};viewFrontN :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> Int -> m (Maybe a);viewFrontN Buffer{..} i = do { !f <- UM.unsafeRead bufferVars _bufferFrontPos; !b <- UM.unsafeRead bufferVars _bufferBackPos; if inRange (f, b - 1) (f + i) then Just <$> UM.read internalBuffer (f + i) else return Nothing};{-# INLINE viewFrontN #-};viewBackN :: (U.Unbox a, PrimMonad m) => Buffer (PrimState m) a -> Int -> m (Maybe a);viewBackN Buffer{..} i = do { !f <- UM.unsafeRead bufferVars _bufferFrontPos; !b <- UM.unsafeRead bufferVars _bufferBackPos; if inRange (f, b - 1) (b - 1 - i) then Just <$> UM.read internalBuffer (b - 1 - i) else return Nothing};{-# INLINE viewBackN #-};data MaxFlow s c = MaxFlow{nVertsMF :: !Int, nEdgesMF :: !Int, offsetsMF :: !(U.Vector Int), edgeDstMF :: !(U.Vector Int), edgeRevIndexMF :: !(U.Vector Int), edgeCapMF :: !(UM.MVector s c)};data MaxFlowBuffer s c = MaxFlowBuffer{distsMF :: !(UM.MVector s Int), queueMF :: !(Buffer s Vertex), iterMF :: !(UM.MVector s Int)};maxFlow :: (U.Unbox c, Num c, Ord c, Bounded c) => Int -> Int -> Int -> U.Vector (Vertex, Vertex, c) -> c;maxFlow !nVerts !src !sink !edges = runST $ do { fst <$> maxFlow' nVerts src sink edges};maxFlow' :: (PrimMonad m, U.Unbox c, Num c, Ord c, Bounded c) => Int -> Int -> Int -> U.Vector (Vertex, Vertex, c) -> m (c, MaxFlow (PrimState m) c);maxFlow' !nVerts !src !sink !edges = do { !container <- buildMaxFlow nVerts edges; !flow <- runMaxFlow src sink container; return (flow, container)};edgesMF :: (PrimMonad m, U.Unbox c, Num c, Ord c, Bounded c) => MaxFlow (PrimState m) c -> m (U.Vector (Int, Int, c, c));edgesMF MaxFlow{..} = do { !edgeCap <- U.unsafeFreeze edgeCapMF; let { next (!i12, !v1) | i12 == offsetsMF U.! (v1 + 1) = next (i12, v1 + 1) | otherwise = ((v1, v2, cap, flow), (i12 + 1, v1)) where { v2 = edgeDstMF U.! i12; i21 = edgeRevIndexMF U.! i12; flow = edgeCap U.! i21; cap = edgeCap U.! i12 + edgeCap U.! i21}}; return $ U.unfoldrExactN nEdgesMF next ((0 :: Vertex), 0 :: Int)};undefMF :: Int;undefMF = -1;buildMaxFlow :: forall c m . (U.Unbox c, Num c, PrimMonad m) => Int -> U.Vector (Vertex, Vertex, c) -> m (MaxFlow (PrimState m) c);buildMaxFlow !nVertsMF !edges = do { let { !offsetsMF = U.scanl' (+) (0 :: Int) $ U.create $ do { !degs <- UM.replicate nVertsMF (0 :: Int); G.forM_ edges $ \ (!v1, !v2, !_) -> do { GM.modify degs (+ 1) v1; GM.modify degs (+ 1) v2}; return degs}}; (!edgeDstMF, !edgeRevIndexMF, !edgeCapMF) <- do { !edgeDst <- UM.replicate nEdgesMF undefMF; !edgeRevIndex <- UM.replicate nEdgesMF undefMF; !edgeCap <- UM.replicate nEdgesMF (0 :: c); !edgeCounter <- U.thaw offsetsMF; G.forM_ edges $ \ (!v1, !v2, !cap) -> do { !i1 <- GM.read edgeCounter v1; !i2 <- GM.read edgeCounter v2; GM.modify edgeCounter (+ 1) v1; GM.modify edgeCounter (+ 1) v2; GM.write edgeRevIndex i1 i2; GM.write edgeRevIndex i2 i1; GM.write edgeDst i1 v2; GM.write edgeDst i2 v1; GM.write edgeCap i1 cap}; (, , edgeCap) <$> G.unsafeFreeze edgeDst <*> G.unsafeFreeze edgeRevIndex}; return MaxFlow{..}} where { !nEdgesMF = G.length edges * 2};runMaxFlow :: forall c m . (U.Unbox c, Num c, Ord c, Bounded c, PrimMonad m) => Vertex -> Vertex -> MaxFlow (PrimState m) c -> m c;runMaxFlow !src !sink container@MaxFlow{..} = do { bufs@MaxFlowBuffer{..} <- MaxFlowBuffer <$> UM.unsafeNew nVertsMF <*> newBufferAsQueue nVertsMF <*> U.thaw offsetsMF; flip fix 0 $ \ loopBfs !flow -> do { GM.set distsMF undefMF; clearBuffer queueMF; runMaxFlowBfs src sink container bufs; !distSink <- UM.read distsMF sink; if distSink == undefMF then return flow else do { U.unsafeCopy iterMF offsetsMF; flip fix flow $ \ loopDfs f -> do { !df <- runMaxFlowDfs src sink maxBound container bufs; if df > 0 then loopDfs $! f + df else loopBfs f}}}};runMaxFlowBfs :: forall c m . (U.Unbox c, Num c, Ord c, PrimMonad m) => Vertex -> Vertex -> MaxFlow (PrimState m) c -> MaxFlowBuffer (PrimState m) c -> m ();runMaxFlowBfs !src !sink MaxFlow{..} MaxFlowBuffer{..} = do { UM.write distsMF src 0; pushBack queueMF src; fix $ \ loop -> popFront queueMF >>= \case { Nothing -> return (); Just !v1 -> do { !notEnd <- (== undefMF) <$> UM.read distsMF sink; when notEnd $ do { let { !iStart = offsetsMF U.! v1; !iEnd = offsetsMF U.! (v1 + 1)}; !dist1 <- UM.read distsMF v1; U.forM_ (U.generate (iEnd - iStart) (+ iStart)) $ \ i12 -> do { let { !v2 = edgeDstMF U.! i12}; !cap12 <- UM.read edgeCapMF i12; !notVisited <- (== undefMF) <$> UM.read distsMF v2; when (cap12 > 0 && notVisited) $ do { UM.write distsMF v2 (dist1 + 1); pushBack queueMF v2}}; loop}}}};runMaxFlowDfs :: forall c m . (U.Unbox c, Num c, Ord c, PrimMonad m) => Vertex -> Vertex -> c -> MaxFlow (PrimState m) c -> MaxFlowBuffer (PrimState m) c -> m c;runMaxFlowDfs !v0 !sink !flow0 MaxFlow{..} MaxFlowBuffer{..} = runDfs v0 flow0 where { runDfs !v1 !flow | v1 == sink = return flow | otherwise = fix $ \ visitNeighbor -> do { !i1 <- UM.read iterMF v1; if i1 >= offsetsMF U.! (v1 + 1) then do { return 0} else do { UM.write iterMF v1 (i1 + 1); let { !v2 = edgeDstMF U.! i1}; !cap12 <- UM.read edgeCapMF i1; !connected <- (<) <$> UM.read distsMF v1 <*> UM.read distsMF v2; if cap12 > 0 && connected then do { !flow' <- runDfs v2 $! min flow cap12; if flow' > 0 then do { modifyFlow i1 flow'; return flow'} else visitNeighbor} else visitNeighbor}}; modifyFlow !i1 !flow = do { UM.modify edgeCapMF (subtract flow) i1; UM.modify edgeCapMF (+ flow) (edgeRevIndexMF U.! i1)}};chunksOfG :: (G.Vector v a) => Int -> v a -> V.Vector (v a);chunksOfG k xs0 = V.unfoldrExactN n step xs0 where { n = (G.length xs0 + k - 1) `div` k; step xs = (G.take k xs, G.drop k xs)};{-# INLINE slideMinIndicesOn #-};slideMinIndicesOn :: (G.Vector v a, Ord b) => (a -> b) -> Int -> v a -> U.Vector Int;slideMinIndicesOn wrap len xs = runST $ do { !buf <- newBufferAsQueue (G.length xs); G.generateM (G.length xs) $ \ i -> do { fix $ \ loop -> do { whenM (maybe False (<= i - len) <$> viewFront buf) $ do { void $ popFront buf; loop}}; fix $ \ loop -> do { whenM (maybe False ((< wrap (xs G.! i)) . wrap . (xs G.!)) <$> viewBack buf) $ do { void $ popBack buf; loop}}; pushBack buf i; fromJust <$> viewFront buf}};{-# INLINE slideMinIndices #-};slideMinIndices :: Int -> U.Vector Int -> U.Vector Int;slideMinIndices = slideMinIndicesOn id;{-# INLINE slideMaxIndices #-};slideMaxIndices :: Int -> U.Vector Int -> U.Vector Int;slideMaxIndices = slideMinIndicesOn Down;{-# INLINE bsearch #-};bsearch :: (G.Vector v a) => v a -> (a -> Bool) -> (Maybe Int, Maybe Int);bsearch !vec !p = bisect 0 (G.length vec - 1) (p . (vec G.!));{-# INLINE bsearchL #-};bsearchL :: (G.Vector v a) => v a -> (a -> Bool) -> Maybe Int;bsearchL !vec !p = bisectL 0 (G.length vec - 1) (p . (vec G.!));{-# INLINE bsearchR #-};bsearchR :: (G.Vector v a) => v a -> (a -> Bool) -> Maybe Int;bsearchR !vec !p = bisectR 0 (G.length vec - 1) (p . (vec G.!));{-# INLINE bsearchExact #-};bsearchExact :: (G.Vector v a, Ord b) => v a -> (a -> b) -> b -> Maybe Int;bsearchExact !vec f !xref = case bisectL 0 (G.length vec - 1) ((<= xref) . f . (vec G.!)) of { Just !x | f (vec G.! x) == xref -> Just x; _ -> Nothing};{-# INLINE bisect #-};bisect :: Int -> Int -> (Int -> Bool) -> (Maybe Int, Maybe Int);bisect !l !r = runIdentity . bisectM l r . (return .);{-# INLINE bisectL #-};bisectL :: Int -> Int -> (Int -> Bool) -> Maybe Int;bisectL !a !b !c = fst $! bisect a b c;{-# INLINE bisectR #-};bisectR :: Int -> Int -> (Int -> Bool) -> Maybe Int;bisectR !a !b !c = snd $! bisect a b c;{-# INLINE bisectM #-};bisectM :: forall m . (Monad m) => Int -> Int -> (Int -> m Bool) -> m (Maybe Int, Maybe Int);bisectM !low !high !isOk = both wrap <$> inner (low - 1) (high + 1) where { inner :: Int -> Int -> m (Int, Int); inner !ok !ng | abs (ok - ng) == 1 = return (ok, ng); inner !ok !ng = isOk m >>= \case { True -> inner m ng; False -> inner ok m} where { !m = (ok + ng) `div` 2}; wrap :: Int -> Maybe Int; wrap !x | inRange (low, high) x = Just x | otherwise = Nothing};{-# INLINE bisectML #-};bisectML :: forall m . (Monad m) => Int -> Int -> (Int -> m Bool) -> m (Maybe Int);bisectML !a !b !c = fst <$> bisectM a b c;{-# INLINE bisectRM #-};bisectRM :: forall m . (Monad m) => Int -> Int -> (Int -> m Bool) -> m (Maybe Int);bisectRM !a !b !c = snd <$> bisectM a b c;{-# INLINE bisectF32 #-};bisectF32 :: Float -> Float -> Float -> (Float -> Bool) -> (Maybe Float, Maybe Float);bisectF32 !low !high !diff !isOk = both wrap (inner (low - diff) (high + diff)) where { inner :: Float -> Float -> (Float, Float); inner !ok !ng | abs (ok - ng) <= diff = (ok, ng); inner !ok !ng | isOk m = inner m ng | otherwise = inner ok m where { !m = (ok + ng) / 2}; wrap :: Float -> Maybe Float; wrap !x | x == (low - diff) || x == (high + diff) = Nothing | otherwise = Just x};{-# INLINE bisectF32L #-};bisectF32L :: Float -> Float -> Float -> (Float -> Bool) -> Maybe Float;bisectF32L !a !b !c !d = fst $! bisectF32 a b c d;{-# INLINE bisectF32R #-};bisectF32R :: Float -> Float -> Float -> (Float -> Bool) -> Maybe Float;bisectF32R !a !b !c !d = snd $! bisectF32 a b c d;{-# INLINE bisectF64 #-};bisectF64 :: Double -> Double -> Double -> (Double -> Bool) -> (Maybe Double, Maybe Double);bisectF64 !low !high !diff !isOk = both wrap (inner (low - diff) (high + diff)) where { inner :: Double -> Double -> (Double, Double); inner !ok !ng | abs (ok - ng) < diff = (ok, ng); inner !ok !ng | isOk m = inner m ng | otherwise = inner ok m where { !m = (ok + ng) / 2}; wrap :: Double -> Maybe Double; wrap !x | x == (low - diff) || x == (high + diff) = Nothing | otherwise = Just x};{-# INLINE bisectF64L #-};bisectF64L :: Double -> Double -> Double -> (Double -> Bool) -> Maybe Double;bisectF64L !a !b !c !d = fst $! bisectF64 a b c d;{-# INLINE bisectF64R #-};bisectF64R :: Double -> Double -> Double -> (Double -> Bool) -> Maybe Double;bisectF64R !a !b !c !d = snd $! bisectF64 a b c d;isqrtSlow :: Int -> Int;isqrtSlow n = fromJust $ bisectR 0 n ((< n) . (^ (2 :: Int)));compressU :: (HasCallStack) => U.Vector Int -> (U.Vector Int, U.Vector Int);compressU xs = (indexer, U.map (fromJust . fst . f) xs) where { !indexer = U.uniq $ U.modify VAI.sort xs; f !x = bisect 0 (pred (U.length indexer)) $ \ i -> indexer U.! i <= x};invNumG :: (HasCallStack) => Int -> (G.Vector v Int) => v Int -> Int;invNumG xMax xs = runST $ do { !stree <- newSTreeU (+) (xMax + 1) (0 :: Int); (\ f -> G.foldM' f (0 :: Int) xs) $ \ acc x -> do { !s <- if x == xMax then return 0 else fromJust <$> querySTree stree (succ x) xMax; modifySTree stree succ x; return $! acc + s}};compressInvNumG :: (HasCallStack) => U.Vector Int -> Int;compressInvNumG xs = invNumG (pred (U.length xs')) xs' where { !xs' = snd $ compressU xs};twoPointers :: Int -> (Int -> Int -> Bool) -> [(Int, Int)];twoPointers !n !p = unfoldr (uncurry f) s0 where { !s0 = (0, 0) :: (Int, Int); f l r | l == n = Nothing | not (p l r) = f (l + 1) (max (l + 1) r) | otherwise = Just ((l, r'), (l + 1, max (l + 1) r')) where { r' = until ((||) <$> (== n - 1) <*> not . p l . succ) succ r}};twoPointersU :: Int -> (Int -> Int -> Bool) -> U.Vector (Int, Int);twoPointersU !n !p = U.unfoldr (uncurry f) s0 where { !s0 = (0, 0) :: (Int, Int); f l r | l == n = Nothing | not (p l r) = f (l + 1) (max (l + 1) r) | otherwise = Just ((l, r'), (l + 1, max (l + 1) r')) where { r' = until ((||) <$> (== n - 1) <*> not . p l . succ) succ r}};imos2D :: ((Int, Int), (Int, Int)) -> UArray (Int, Int) Int -> UArray (Int, Int) Int;imos2D !bounds_ !seeds = runSTUArray $ do { !arr <- newArray bounds_ (0 :: Int); let { (!minY, !minX) = fst bounds_}; forM_ (range bounds_) $ \ (!y, !x) -> do { !v <- if x == minX then return 0 else readArray arr (y, x - 1); let { !diff = seeds ! (y, x)}; writeArray arr (y, x) $! v + diff}; forM_ (range bounds_) $ \ (!x, !y) -> do { !v <- if y == minY then return 0 else readArray arr (y - 1, x); !diff <- readArray arr (y, x); writeArray arr (y, x) $! v + diff}; return arr};imos2DRev :: ((Int, Int), (Int, Int)) -> UArray (Int, Int) Int -> UArray (Int, Int) Int;imos2DRev !bounds_ !seeds = runSTUArray $ do { !arr <- newArray bounds_ (0 :: Int); let { (!minY, !minX) = fst bounds_}; let { (!maxY, !maxX) = snd bounds_}; forM_ [maxX, maxX - 1 .. minX] $ \ x -> do { forM_ [maxY, maxY - 1 .. minY] $ \ y -> do { !v <- if x == maxX then return 0 else readArray arr (y, x + 1); let { !diff = seeds ! (y, x)}; writeArray arr (y, x) $! v + diff}}; forM_ [maxX, maxX - 1 .. minX] $ \ x -> do { forM_ [maxY, maxY - 1 .. minY] $ \ y -> do { !v <- if y == maxY then return 0 else readArray arr (y + 1, x); !diff <- readArray arr (y, x); writeArray arr (y, x) $! v + diff}}; return arr};rolls :: (RandomGen g, UniformRange a, U.Unbox a) => Int -> (a, a) -> g -> U.Vector a;rolls n rng = U.unfoldrExactN n (uniformR rng);rollsM :: (StatefulGen g m, UniformRange a, U.Unbox a) => Int -> (a, a) -> g -> m (U.Vector a);rollsM n rng = U.replicateM n . uniformRM rng;uniformRSt :: (RandomGen g, UniformRange a, MonadState g m) => (a, a) -> m a;uniformRSt !rng = state (uniformR rng);int :: IO Int;int = readLn;ints :: IO [Int];ints = unfoldr (BS.readInt . BS.dropWhile isSpace) <$> BS.getLine;class ReadBS a where { {-# INLINE convertBS #-}; convertBS :: BS.ByteString -> a; default convertBS :: (Read a) => BS.ByteString -> a; convertBS = read . BS.unpack; {-# INLINE readBS #-}; readBS :: BS.ByteString -> (a, BS.ByteString); readBS !bs = let { (!bs1, !bs2) = BS.break isSpace bs} in (convertBS bs1, bs2); {-# INLINE readMayBS #-}; readMayBS :: BS.ByteString -> Maybe (a, BS.ByteString); readMayBS !bs | BS.null bs = Nothing | otherwise = let { (!bs1, !bs2) = BS.break isSpace bs} in Just (convertBS bs1, bs2)};instance ReadBS Int where { {-# INLINE convertBS #-}; convertBS = fst . readBS; {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS = BS.readInt};instance ReadBS Integer where { {-# INLINE convertBS #-}; convertBS = fst . readBS; {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS = BS.readInteger};instance ReadBS Float;instance ReadBS Double;instance ReadBS Char where { {-# INLINE convertBS #-}; convertBS = BS.head};instance ReadBS String where { {-# INLINE convertBS #-}; convertBS = BS.unpack};instance ReadBS BS.ByteString where { {-# INLINE convertBS #-}; convertBS = id};instance (ReadBS a, U.Unbox a) => ReadBS (U.Vector a) where { {-# INLINE convertBS #-}; convertBS = convertG; readBS = (, BS.empty) . convertG; readMayBS !bs | BS.null bs = Nothing | otherwise = Just (readBS bs)};instance (ReadBS a) => ReadBS (V.Vector a) where { {-# INLINE convertBS #-}; convertBS = convertG; readBS = (, BS.empty) . convertG; readMayBS !bs | BS.null bs = Nothing | otherwise = Just (readBS bs)};instance (ReadBS a1, ReadBS a2) => ReadBS (a1, a2) where { {-# INLINE convertBS #-}; convertBS !bs0 = let { (!a1, !bs1) = readBS (BS.dropWhile isSpace bs0); !a2 = convertBS (BS.dropWhile isSpace bs1)} in (a1, a2); {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS !bs0 = do { (!x1, !bs1) <- readMayBS bs0; (!x2, !bs2) <- readMayBS bs1; Just ((x1, x2), bs2)}};instance (ReadBS a1, ReadBS a2, ReadBS a3) => ReadBS (a1, a2, a3) where { {-# INLINE convertBS #-}; convertBS !bs0 = let { (!a1, !bs1) = readBS (BS.dropWhile isSpace bs0); (!a2, !bs2) = readBS (BS.dropWhile isSpace bs1); !a3 = convertBS (BS.dropWhile isSpace bs2)} in (a1, a2, a3); {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS !bs0 = do { (!x1, !bs1) <- readMayBS bs0; (!x2, !bs2) <- readMayBS bs1; (!x3, !bs3) <- readMayBS bs2; Just ((x1, x2, x3), bs3)}};instance (ReadBS a1, ReadBS a2, ReadBS a3, ReadBS a4) => ReadBS (a1, a2, a3, a4) where { {-# INLINE convertBS #-}; convertBS !bs0 = let { (!a1, !bs1) = readBS (BS.dropWhile isSpace bs0); (!a2, !bs2) = readBS (BS.dropWhile isSpace bs1); (!a3, !bs3) = readBS (BS.dropWhile isSpace bs2); !a4 = convertBS (BS.dropWhile isSpace bs3)} in (a1, a2, a3, a4); {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS !bs0 = do { (!x1, !bs1) <- readMayBS bs0; (!x2, !bs2) <- readMayBS bs1; (!x3, !bs3) <- readMayBS bs2; (!x4, !bs4) <- readMayBS bs3; Just ((x1, x2, x3, x4), bs4)}};instance (ReadBS a1, ReadBS a2, ReadBS a3, ReadBS a4, ReadBS a5) => ReadBS (a1, a2, a3, a4, a5) where { {-# INLINE convertBS #-}; convertBS !bs0 = let { (!a1, !bs1) = readBS (BS.dropWhile isSpace bs0); (!a2, !bs2) = readBS (BS.dropWhile isSpace bs1); (!a3, !bs3) = readBS (BS.dropWhile isSpace bs2); (!a4, !bs4) = readBS (BS.dropWhile isSpace bs3); !a5 = convertBS (BS.dropWhile isSpace bs4)} in (a1, a2, a3, a4, a5); {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS !bs0 = do { (!x1, !bs1) <- readMayBS bs0; (!x2, !bs2) <- readMayBS bs1; (!x3, !bs3) <- readMayBS bs2; (!x4, !bs4) <- readMayBS bs3; (!x5, !bs5) <- readMayBS bs4; Just ((x1, x2, x3, x4, x5), bs5)}};instance (ReadBS a1, ReadBS a2, ReadBS a3, ReadBS a4, ReadBS a5, ReadBS a6) => ReadBS (a1, a2, a3, a4, a5, a6) where { {-# INLINE convertBS #-}; convertBS !bs0 = let { (!a1, !bs1) = readBS (BS.dropWhile isSpace bs0); (!a2, !bs2) = readBS (BS.dropWhile isSpace bs1); (!a3, !bs3) = readBS (BS.dropWhile isSpace bs2); (!a4, !bs4) = readBS (BS.dropWhile isSpace bs3); (!a5, !bs5) = readBS (BS.dropWhile isSpace bs4); !a6 = convertBS (BS.dropWhile isSpace bs5)} in (a1, a2, a3, a4, a5, a6); {-# INLINE readBS #-}; readBS = fromJust . readMayBS; {-# INLINE readMayBS #-}; readMayBS !bs0 = do { (!x1, !bs1) <- readMayBS bs0; (!x2, !bs2) <- readMayBS bs1; (!x3, !bs3) <- readMayBS bs2; (!x4, !bs4) <- readMayBS bs3; (!x5, !bs5) <- readMayBS bs4; (!x6, !bs6) <- readMayBS bs5; Just ((x1, x2, x3, x4, x5, x6), bs6)}};convertG :: (ReadBS a, G.Vector v a) => BS.ByteString -> v a;convertG = G.unfoldr (readMayBS . BS.dropWhile isSpace);convertNG :: (ReadBS a, G.Vector v a) => Int -> BS.ByteString -> v a;convertNG !n = G.unfoldrExactN n (readBS . BS.dropWhile isSpace);auto :: (ReadBS a) => IO a;auto = convertBS <$> BS.getLine;ints1 :: IO Int;ints1 = auto;ints2 :: IO (Int, Int);ints2 = auto;ints3 :: IO (Int, Int, Int);ints3 = auto;ints4 :: IO (Int, Int, Int, Int);ints4 = auto;ints5 :: IO (Int, Int, Int, Int, Int);ints5 = auto;ints6 :: IO (Int, Int, Int, Int, Int, Int);ints6 = auto;intsW :: (G.Vector v Int) => Int -> IO (v Int);intsW !w = G.unfoldrExactN w (fromJust . BS.readInt . BS.dropWhile isSpace) <$> BS.getLine;intsG :: (G.Vector v Int) => IO (v Int);intsG = G.unfoldr (BS.readInt . BS.dropWhile isSpace) <$> BS.getLine;intsV :: IO (V.Vector Int);intsV = intsG;intsU :: IO (U.Vector Int);intsU = intsG;digitsU :: IO (U.Vector Int);digitsU = U.unfoldr (fmap (first digitToInt) . BS.uncons) <$> BS.getLine;convertNBS :: forall a . (U.Unbox a, ReadBS a) => Int -> V.Vector BS.ByteString -> U.Vector a;convertNBS !n !bss = U.unfoldrExactN n step $ fromJust (V.uncons bss) where { step :: (BS.ByteString, V.Vector BS.ByteString) -> (a, (BS.ByteString, V.Vector BS.ByteString)); step (!cur, !rest) | BS.null cur' = step $ fromJust (V.uncons rest) | otherwise = let { (!x, !cur'') = readBS cur'} in (x, (cur'', rest)) where { !cur' = BS.dropWhile isSpace cur}};getHW :: (U.Unbox a, ReadBS a) => Int -> Int -> IO (U.Vector a);getHW !h !w = convertNBS (h * w) <$> V.replicateM h BS.getLine;getMat :: Int -> Int -> IO (IxVector (Int, Int) (U.Vector Int));getMat !h !w = IxVector ((0, 0), (h - 1, w - 1)) <$> getHW h w;convertCharsHW :: V.Vector BS.ByteString -> U.Vector Char;convertCharsHW !bss = U.create $ do { !vec <- UM.unsafeNew (h * w); V.iforM_ bss $ \ y bs -> forM_ [0 .. w - 1] $ \ x -> do { let { !char = BS.index bs x}; UM.unsafeWrite vec (w * y + x) char}; return vec} where { !w = BS.length (V.head bss); !h = V.length bss};getGrid :: Int -> Int -> IO (IxUVector (Int, Int) Char);getGrid !h !w = IxVector ((0, 0), (h - 1, w - 1)) . convertCharsHW <$> V.replicateM h BS.getLine;{-# INLINE endlBSB #-};endlBSB :: BSB.Builder;endlBSB = BSB.char7 '\n';putBSB :: BSB.Builder -> IO ();putBSB = BSB.hPutBuilder stdout;putLnBSB :: BSB.Builder -> IO ();putLnBSB = BSB.hPutBuilder stdout . (<> endlBSB);class ShowBSB a where { showBSB :: a -> BSB.Builder; default showBSB :: (Show a) => a -> BSB.Builder; showBSB = BSB.string8 . show};instance ShowBSB Int where { showBSB = BSB.intDec};instance ShowBSB Integer where { showBSB = BSB.integerDec};instance ShowBSB Float where { showBSB = BSB.floatDec};instance ShowBSB Double where { showBSB = BSB.doubleDec};showLnBSB :: (ShowBSB a) => a -> BSB.Builder;showLnBSB = (<> endlBSB) . showBSB;printBSB :: (ShowBSB a) => a -> IO ();printBSB = putBSB . showBSB;concatBSB :: (G.Vector v a) => (a -> BSB.Builder) -> v a -> BSB.Builder;concatBSB f = G.foldr' ((<>) . f) mempty;unwordsBSB :: (ShowBSB a, G.Vector v a) => v a -> BSB.Builder;unwordsBSB = concatBSB ((<> BSB.string7 " ") . showBSB);unlinesBSB :: (ShowBSB a, G.Vector v a) => v a -> BSB.Builder;unlinesBSB = concatBSB showLnBSB;yn :: Bool -> String;yn = bool "No" "Yes";ynBSB :: Bool -> BSB.Builder;ynBSB = bool (BSB.string8 "No") (BSB.string8 "Yes");printYn :: Bool -> IO ();printYn = putLnBSB . ynBSB;printList :: (Show a) => [a] -> IO ();printList = putStrLn . unwords . map show;putList :: (Show a) => [a] -> IO ();putList = putStr . unwords . map show;boundsSize2 :: ((Int, Int), (Int, Int)) -> (Int, Int);boundsSize2 ((!y1, !x1), (!y2, !x2)) = (y2 - y1 + 1, x2 - x1 + 1);printGrid :: IxUVector (Int, Int) Char -> IO ();printGrid gr = do { let { !rows = V.unfoldrExactN h (U.splitAt w) (vecIV gr)}; V.forM_ rows $ putStrLn . U.toList} where { (!h, !w) = boundsSize2 (boundsIV gr)};class ShowGrid a where { showGrid :: a -> String; showGridN :: Int -> a -> String};instance (G.Vector v a, Show a) => ShowGrid (IxVector (Int, Int) (v a)) where { showGrid = showGridN 0; showGridN !len !grid = unlines $ map f [y0 .. y1] where { ((!y0, !x0), (!y1, !x1)) = boundsIV grid; f !y = unwords $ map (showN . (grid @!) . (y,)) [x0 .. x1]; showN x = let { !s = show x; !lenX = length s} in replicate (len - lenX) ' ' ++ s}};($$) :: (Show a) => (a -> b) -> a -> b;($$) lhs rhs = lhs (dbgId rhs);infixr 0 $$;(.$) :: (Show b) => (b -> c) -> (a -> b) -> a -> c;g .$ f = \ a -> let { !b = dbgId (f a)} in g b;infixr 9 .$;dbgGrid :: (ShowGrid a) => a -> ();dbgGrid !gr = dbgS (showGrid gr);dbgGridId :: (ShowGrid a) => a -> a;dbgGridId !gr = let { !_ = dbgS (showGrid gr)} in gr;dbgGridN :: (ShowGrid a) => Int -> a -> ();dbgGridN !len !gr = dbgS (showGridN len gr);dbgGridNId :: (ShowGrid a) => Int -> a -> a;dbgGridNId !len !gr = let { !_ = dbgS (showGridN len gr)} in gr;dbgUF :: (PrimMonad m) => MUnionFind (PrimState m) -> m ();dbgUF (MUnionFind vec) = dbgUM vec;dbgUM :: (Show (v a), G.Vector v a, PrimMonad m) => (G.Mutable v) (PrimState m) a -> m ();dbgUM vec = do { !xs' <- G.unsafeFreeze vec; let { !_ = dbg xs'}; return ()};dbgSTree :: (Show (v a), G.Vector v a, PrimMonad m) => SegmentTree (G.Mutable v) (PrimState m) a -> m ();dbgSTree (SegmentTree _ mVec) = do { !vec <- G.unsafeFreeze mVec; let { !leaves = G.drop (G.length vec `div` 2 - 1) vec}; let { !_ = dbg leaves}; return ()};dbgSTreeAll :: (Show (v a), G.Vector v a, PrimMonad m) => SegmentTree (G.Mutable v) (PrimState m) a -> m ();dbgSTreeAll (SegmentTree _ mVec) = do { !vec <- G.unsafeFreeze mVec; flip fix (0 :: Int, 1 :: Int) $ \ loop (!n, !len) -> do { unless (G.length vec <= len) $ do { let { !vec' = G.take len . G.drop (len - 1) $ vec}; let { !_ = dbgS $ "> " ++ show vec'}; loop (n + 1, 2 * len)}}};clamp :: (Ord a) => (a, a) -> a -> a;clamp (!low, !high) !a = min high (max a low);flipOrder :: Ordering -> Ordering;flipOrder = \case { GT -> LT; LT -> GT; EQ -> EQ};square :: (Num a) => a -> a;square !x = x * x;isqrt :: Int -> Int;isqrt = round @Double . sqrt . fromIntegral;{-# INLINE modifyArray #-};modifyArray :: (MArray a e m, Ix i) => a i e -> (e -> e) -> i -> m ();modifyArray !ary !f !i = do { !v <- f <$> readArray ary i; writeArray ary i v};{-# INLINE (.:) #-};(.:) :: (b -> c) -> (a1 -> a2 -> b) -> (a1 -> a2 -> c);(.:) = (.) . (.);swapDupeU :: U.Vector (Int, Int) -> U.Vector (Int, Int);swapDupeU = U.concatMap (\ vs -> U.fromListN 2 [vs, swap vs]);swapDupeW :: U.Vector (Int, Int, Int) -> U.Vector (Int, Int, Int);swapDupeW = U.concatMap (\ (!v1, !v2, !d) -> U.fromListN 2 [(v1, v2, d), (v2, v1, d)]);ortho4 :: U.Vector (Int, Int);ortho4 = U.fromList [(0, 1), (0, -1), (1, 0), (-1, 0)];{-# INLINE ortho4' #-};ortho4' :: ((Int, Int), (Int, Int)) -> (Int, Int) -> U.Vector (Int, Int);ortho4' bnd base = U.filter (inRange bnd) $ U.map (add2 base) ortho4;{-# INLINE slice #-};slice :: (G.Vector v a) => Int -> Int -> v a -> v a;slice !l !r !vec = G.slice l (max 0 (r - l + 1)) vec;constructN0 :: (U.Unbox a) => a -> Int -> (U.Vector a -> a) -> U.Vector a;constructN0 !x0 !n !f = U.constructN n $ \ vec -> if U.null vec then x0 else f vec;{-# INLINE rangeG #-};rangeG :: (G.Vector v Int) => Int -> Int -> v Int;rangeG !i !j = G.enumFromN i (succ j - i);{-# INLINE rangeV #-};rangeV :: Int -> Int -> V.Vector Int;rangeV = rangeG;{-# INLINE rangeU #-};rangeU :: Int -> Int -> U.Vector Int;rangeU = rangeG;{-# INLINE rangeGR #-};rangeGR :: (G.Vector v Int) => Int -> Int -> v Int;rangeGR !i !j = G.enumFromStepN j (-1) (succ j - i);{-# INLINE rangeVR #-};rangeVR :: Int -> Int -> V.Vector Int;rangeVR = rangeGR;{-# INLINE rangeUR #-};rangeUR :: Int -> Int -> U.Vector Int;rangeUR = rangeGR;{-# INLINE repM_ #-};repM_ :: (Monad m) => Int -> Int -> (Int -> m ()) -> m ();repM_ !l !r !act = inner l where { inner !i | i > r = return () | otherwise = act i >> inner (succ i)};{-# INLINE repRM_ #-};repRM_ :: (Monad m) => Int -> Int -> (Int -> m ()) -> m ();repRM_ !l !r !act = inner r where { inner !i | i < l = return () | otherwise = act i >> inner (pred i)};{-# INLINE times #-};times :: Int -> (a -> a) -> a -> a;times !n !f = inner 0 where { inner i !s | i >= n = s | otherwise = inner (i + 1) $! f s};interleave :: [a] -> [a] -> [a];interleave xs [] = xs; interleave [] ys = ys; interleave (x : xs) (y : ys) = x : y : interleave xs ys;combs :: Int -> [a] -> [[a]];combs _ [] = []; combs k as@(!(_ : xs)) | k == 0 = [[]] | k == 1 = map pure as | k == l = pure as | k > l = [] | otherwise = run (l - 1) (k - 1) as $ combs (k - 1) xs where { l = length as; run :: Int -> Int -> [a] -> [[a]] -> [[a]]; run n k ys cs | n == k = map (ys ++) cs | otherwise = map (q :) cs ++ run (n - 1) k qs (drop dc cs) where { (!(q : qs)) = take (n - k + 1) ys; dc = product [(n - k + 1) .. (n - 1)] `div` product [1 .. (k - 1)]}};swapDupe :: (a, a) -> [(a, a)];swapDupe (!x1, !x2) = [(x1, x2), (x2, x1)];add2 :: (Int, Int) -> (Int, Int) -> (Int, Int);add2 (!y, !x) = bimap (y +) (x +);sub2 :: (Int, Int) -> (Int, Int) -> (Int, Int);sub2 (!y, !x) = bimap (y -) (x -);mul2 :: Int -> (Int, Int) -> (Int, Int);mul2 !m = both (m *);add3 :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int);add3 (!z1, !y1, !x1) (!z2, !y2, !x2) = (z1 + z2, y1 + y2, x1 + x2);sub3 :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int);sub3 (!z1, !y1, !x1) (!z2, !y2, !x2) = (z1 - z2, y1 - y2, x1 - x2);mul3 :: (Int, Int, Int) -> (Int, Int, Int) -> (Int, Int, Int);mul3 (!z1, !y1, !x1) (!z2, !y2, !x2) = (z1 - z2, y1 - y2, x1 - x2);toRadian :: Double -> Double;toRadian degree = degree / 180.0 * pi;toDegree :: Double -> Double;toDegree rad = rad / pi * 180.0;fst4 :: (a, b, c, d) -> a;fst4 (!a, !_, !_, !_) = a;snd4 :: (a, b, c, d) -> b;snd4 (!_, !b, !_, !_) = b;thd4 :: (a, b, c, d) -> c;thd4 (!_, !_, !c, !_) = c;fth4 :: (a, b, c, d) -> d;fth4 (!_, !_, !_, !d) = d;first4 :: (a -> x) -> (a, b, c, d) -> (x, b, c, d);first4 f (!a, !b, !c, !d) = (f a, b, c, d);second4 :: (b -> x) -> (a, b, c, d) -> (a, x, c, d);second4 f (!a, !b, !c, !d) = (a, f b, c, d);thidr4 :: (c -> x) -> (a, b, c, d) -> (a, b, x, d);thidr4 f (!a, !b, !c, !d) = (a, b, f c, d);fourth4 :: (d -> x) -> (a, b, c, d) -> (a, b, c, x);fourth4 f (!a, !b, !c, !d) = (a, b, c, f d);newtype BinaryLifting v m = BinaryLifting (v m) deriving (Show, Eq);newBinLift :: (G.Vector v s, Semigroup s) => s -> BinaryLifting v s;newBinLift !op0 = BinaryLifting ops where { !ops = G.iterateN (pred 63) (\ !op -> op <> op) op0};newBinLiftV :: (Semigroup s) => s -> BinaryLifting V.Vector s;newBinLiftV = newBinLift;newBinLiftU :: (Semigroup s, U.Unbox s) => s -> BinaryLifting U.Vector s;newBinLiftU = newBinLift;stimesBL :: (HasCallStack, Semigroup s, G.Vector v s) => BinaryLifting v s -> s -> Int -> s;stimesBL (BinaryLifting !ops) !s0 !n = U.foldl' step s0 (U.enumFromN 0 62) where { step !m !i | testBit n i = m <> ops G.! i | otherwise = m};mtimesBL :: (HasCallStack, Monoid m, G.Vector v m) => BinaryLifting v m -> Int -> m;mtimesBL !bin !n = stimesBL bin mempty n;sactBL :: (HasCallStack, SemigroupAction s a, G.Vector v s) => BinaryLifting v s -> a -> Int -> a;sactBL (BinaryLifting !ops) !acc0 !nAct = U.foldl' step acc0 (rangeG 0 62) where { step !acc !nBit | testBit nAct nBit = (ops G.! nBit) `sact` acc | otherwise = acc};mactBL :: (HasCallStack, MonoidAction m a, G.Vector v m) => BinaryLifting v m -> a -> Int -> a;mactBL = sactBL;newDoubling :: (G.Vector v a, G.Vector v Int) => a -> (a -> a) -> v a;newDoubling !oper0 !squareCompositeF = G.scanl' step oper0 $! G.enumFromN (1 :: Int) 62 where { step !oper !_ = squareCompositeF oper};newDoublingV :: a -> (a -> a) -> V.Vector a;newDoublingV = newDoubling;applyDoubling :: (HasCallStack, G.Vector v op) => v op -> a -> (a -> op -> a) -> Int -> a;applyDoubling !opers !x0 !act !n = foldl' step x0 [0 .. 62] where { !_ = dbgAssert $ G.length opers == 63; step !acc !nBit = if testBit n nBit then acc `act` (opers G.! nBit) else acc};newtype ToParent = ToParent (U.Vector Vertex);instance Semigroup ToParent where { (ToParent !vec1) <> (ToParent !vec2) = ToParent $ U.map f vec2 where { !_ = dbgAssert (G.length vec1 == G.length vec2); f (-1) = -1; f i = vec1 U.! i}};instance SemigroupAction ToParent Vertex where { sact (ToParent !vec) !i = vec U.! i};type LcaCache = (ToParent, U.Vector Int, BinaryLifting V.Vector ToParent);treeDepthInfo :: Int -> (Int -> [Int]) -> Int -> (ToParent, U.Vector Int);treeDepthInfo !nVerts !graph !root = runST $ do { !parents <- UM.replicate nVerts (-1 :: Int); !depths <- UM.replicate nVerts (-1 :: Int); flip fix (0 :: Int, -1 :: Int, [root]) $ \ loop (!depth, !parent, !vs) -> do { forM_ vs $ \ v -> do { UM.unsafeWrite depths v depth; UM.unsafeWrite parents v parent; let { !vs' = filter (/= parent) $ graph v}; loop (succ depth, v, vs')}}; (,) <$> (ToParent <$> U.unsafeFreeze parents) <*> U.unsafeFreeze depths};lcaCache :: Int -> (Vertex -> [Vertex]) -> Vertex -> LcaCache;lcaCache !nVerts !graph !root = (toParent, depths, toParentN) where { (!toParent, !depths) = treeDepthInfo nVerts graph root; !toParentN = newBinLift toParent};lca :: (HasCallStack) => LcaCache -> Int -> Int -> (Int, Int);lca (!_, !depths, !toParentN) !v1 !v2 = (vLCA, depths U.! vLCA) where { !d1 = depths U.! v1; !d2 = depths U.! v2; parentN = sactBL toParentN; !v1' = if d1 <= d2 then v1 else v2; !v2' = parentN (if d1 > d2 then v1 else v2) (abs $ d1 - d2); !dLCA = fromJust . snd $ bisect 0 (min d1 d2) $ \ d -> parentN v1' d /= parentN v2' d; !vLCA = parentN v1' dLCA};lcaLen :: (HasCallStack) => LcaCache -> Int -> Int -> Int;lcaLen cache@(!_, !depths, !_) !v1 !v2 = let { (!_, !d) = lca cache v1 v2; !d1 = depths U.! v1; !d2 = depths U.! v2} in (d1 - d) + (d2 - d);newtype ToParentM m = ToParentM (Int, U.Vector m);type FoldLcaCache m = (LcaCache, V.Vector (U.Vector m));foldLcaCache :: forall m . (Monoid m, U.Unbox m) => Int -> (Vertex -> [Vertex]) -> Vertex -> (Vertex -> Vertex -> m) -> FoldLcaCache m;foldLcaCache !nVerts !graph !root !edgeValueOf = (cache, foldCache) where { !cache@(!parents, !_, BinaryLifting !parents') = lcaCache nVerts graph root; foldCache :: V.Vector (U.Vector m); !foldCache = V.map snd $! newDoubling toParent appendArray where { !toParent = (0, U.map f (rangeG 0 (pred nVerts))) where { f v = case parents `sact` v of { (-1) -> mempty; p -> edgeValueOf v p}}; appendArray (!iBit, !ops) = (succ iBit, U.imap f ops) where { f !v0 !op = case (parents' V.! iBit) `sact` v0 of { (-1) -> op; p -> op <> (ops U.! p)}}}};foldLcaCache2 :: forall a m . (HasCallStack, Monoid m, U.Unbox m) => Array Int [(Vertex, a)] -> (a -> m) -> FoldLcaCache m;foldLcaCache2 !tree !toMonoid = foldLcaCache nVerts adj root getValue where { !root = 0 :: Vertex; !nVerts = rangeSize $ bounds tree; adj = map fst . (tree !); getValue !v !p = toMonoid . snd . fromJust . find ((== p) . fst) $ tree ! v};foldViaLca :: forall m . (HasCallStack, Monoid m, U.Unbox m) => FoldLcaCache m -> Int -> Int -> m;foldViaLca (cache@(!_, !depths, BinaryLifting !parents'), !ops') !v1 !v2 = let { (!_, !d) = lca cache v1 v2; !d1 = depths U.! v1; !d2 = depths U.! v2; !a1 = foldParentN v1 (d1 - d); !a2 = foldParentN v2 (d2 - d)} in a1 <> a2 where { foldParentN :: Vertex -> Int -> m; foldParentN !v0 !nthParent = snd $ V.ifoldl' step (v0, mempty) input where { !input = V.zip parents' ops'; step :: (Vertex, m) -> Int -> (ToParent, U.Vector m) -> (Vertex, m); step (!v, !acc) !iBit (!parents, !ops) | testBit nthParent iBit = (parents `sact` v, acc <> (ops U.! v)) | otherwise = (v, acc)}};data SparseGraph i w = SparseGraph{boundsSG :: !(i, i), nVertsSG :: !Int, nEdgesSG :: !Int, offsetsSG :: !(U.Vector Int), adjacentsSG :: !(U.Vector Vertex), edgeWeightsSG :: !(U.Vector w)} deriving (Show);{-# INLINE buildSG #-};buildSG :: (Unindex i) => (i, i) -> U.Vector (i, i) -> SparseGraph i ();buildSG !boundsSG !edges = buildRawSG boundsSG $ U.map (\ (!i1, !i2) -> (ix i1, ix i2, ())) edges where { ix = index boundsSG};{-# INLINE buildWSG #-};buildWSG :: (Unindex i, UM.Unbox w) => (i, i) -> U.Vector (i, i, w) -> SparseGraph i w;buildWSG !boundsSG !edges = buildRawSG boundsSG $ U.map (\ (!i1, !i2, !w) -> (ix i1, ix i2, w)) edges where { ix = index boundsSG};{-# INLINE buildRawSG #-};buildRawSG :: (Unindex i, UM.Unbox w) => (i, i) -> U.Vector (Vertex, Vertex, w) -> SparseGraph i w;buildRawSG !boundsSG !edges = let { !nEdgesSG = U.length edges; !nVertsSG = rangeSize boundsSG; !offsetsSG = U.scanl' (+) 0 $ U.create $ do { !outDegs <- UM.replicate nVertsSG (0 :: Int); U.forM_ edges $ \ (!v1, !_, !_) -> do { UM.modify outDegs (+ 1) v1}; return outDegs}; !_ = dbgAssert (U.last offsetsSG == nEdgesSG); (!adjacentsSG, !edgeWeightsSG) = runST $ do { !mOffsets <- U.thaw offsetsSG; !mAdjacents <- UM.unsafeNew nEdgesSG; !mWeights <- UM.unsafeNew nEdgesSG; U.forM_ edges $ \ (!v1, !v2, !w) -> do { !iEdgeFlatten <- UM.unsafeRead mOffsets v1; UM.unsafeWrite mOffsets v1 (iEdgeFlatten + 1); UM.unsafeWrite mAdjacents iEdgeFlatten v2; UM.unsafeWrite mWeights iEdgeFlatten w}; (,) <$> U.unsafeFreeze mAdjacents <*> U.unsafeFreeze mWeights}} in SparseGraph{..};{-# INLINE adj #-};adj :: SparseGraph i w -> Vertex -> U.Vector Vertex;adj SparseGraph{..} v = U.unsafeSlice o1 (o2 - o1) adjacentsSG where { !o1 = U.unsafeIndex offsetsSG v; !o2 = U.unsafeIndex offsetsSG (v + 1)};{-# INLINE eAdj #-};eAdj :: SparseGraph i w -> Vertex -> U.Vector (EdgeId, Vertex);eAdj SparseGraph{..} v = U.imap ((,) . (+ o1)) vs where { !o1 = U.unsafeIndex offsetsSG v; !o2 = U.unsafeIndex offsetsSG (v + 1); !vs = U.unsafeSlice o1 (o2 - o1) adjacentsSG};{-# INLINE adjIx #-};adjIx :: (Unindex i) => SparseGraph i w -> i -> U.Vector i;adjIx gr i = U.map (unindex (boundsSG gr)) $ adj gr v where { !v = index (boundsSG gr) i};{-# INLINE adjW #-};adjW :: (U.Unbox w) => SparseGraph i w -> Vertex -> U.Vector (Vertex, w);adjW SparseGraph{..} v = U.zip vs ws where { !o1 = U.unsafeIndex offsetsSG v; !o2 = U.unsafeIndex offsetsSG (v + 1); !vs = U.unsafeSlice o1 (o2 - o1) adjacentsSG; !ws = U.unsafeSlice o1 (o2 - o1) edgeWeightsSG};{-# INLINE adjWIx #-};adjWIx :: (Unindex i, U.Unbox w) => SparseGraph i w -> i -> U.Vector (i, w);adjWIx gr i = U.map (first (unindex (boundsSG gr))) $ adjW gr v where { !v = index (boundsSG gr) i};dfsSG :: (Unindex i) => SparseGraph i w -> i -> IxVector i (U.Vector Int);dfsSG gr@SparseGraph{..} !sourceIx = IxVector boundsSG $ U.create $ do { let { !undef = -1 :: Int}; !dist <- UM.replicate nVertsSG undef; flip fix (0 :: Int, index boundsSG sourceIx) $ \ loop (!depth, !v1) -> do { UM.write dist v1 depth; U.forM_ (gr `adj` v1) $ \ v2 -> do { !d <- UM.read dist v2; when (d == undef) $ do { loop (succ depth, v2)}}}; return dist};dfsEveryPathSG :: SparseGraph Int Int -> Int -> Int;dfsEveryPathSG gr@SparseGraph{..} !source = runST $ do { !vis <- UM.replicate nVertsSG False; flip fix (0 :: Int, source) $ \ loop (!d1, !v1) -> do { UM.write vis v1 True; !v2s <- U.filterM (fmap not . UM.read vis . fst) $ gr `adjW` v1; !maxDistance <- fmap (U.foldl' max (0 :: Int)) . U.forM v2s $ \ (!v2, !w) -> do { loop (d1 + w, v2)}; UM.write vis v1 False; return $ max d1 maxDistance}};componentsVecSG :: (Ix i) => SparseGraph i w -> i -> IxVector i (U.Vector Bool);componentsVecSG gr@SparseGraph{..} !sourceIx = IxVector boundsSG $ U.create $ do { !vis <- UM.replicate nVertsSG False; flip fix source $ \ loop v1 -> do { UM.write vis v1 True; let { !v2s = gr `adj` v1}; U.forM_ v2s $ \ v2 -> do { !visited <- UM.read vis v2; unless visited $ do { loop v2}}}; return vis} where { !source = index boundsSG sourceIx :: Vertex};bfsSG :: (Ix i) => SparseGraph i w -> i -> IxVector i (U.Vector Int);bfsSG gr@SparseGraph{..} !sourceIx = IxVector boundsSG $ genericBfs (gr `adj`) nVertsSG (index boundsSG sourceIx);genericBfs :: (Int -> U.Vector Int) -> Int -> Vertex -> U.Vector Int;genericBfs !gr !nVerts !source = U.create $ do { let { !undef = -1 :: Int}; !dist <- UM.replicate nVerts undef; !queue <- newBufferAsQueue nVerts; pushBack queue source; UM.unsafeWrite dist source (0 :: Int); fix $ \ loop -> do { popFront queue >>= \case { Nothing -> return (); Just !v1 -> do { !d1 <- UM.unsafeRead dist v1; U.forM_ (gr v1) $ \ v2 -> do { !lastD <- UM.unsafeRead dist v2; when (lastD == undef) $ do { UM.unsafeWrite dist v2 (d1 + 1); pushBack queue v2}}; loop}}}; return dist};genericBfs01 :: (Ix i, U.Unbox i) => (i, i) -> (i -> U.Vector (i, Int)) -> U.Vector i -> IxUVector i Int;genericBfs01 !bndExt !gr !sources = IxVector bndExt $ U.create $ do { let { !undef = -1 :: Int}; let { !nVertsExt = rangeSize bndExt}; !vec <- IxVector bndExt <$> UM.replicate nVertsExt undef; !deque <- newBufferAsDeque nVertsExt; U.forM_ sources $ \ vExt -> do { pushFront deque (0 :: Int, vExt); writeIV vec vExt (0 :: Int)}; let { step !w0 !vExt0 = do { !wReserved0 <- readIV vec vExt0; when (w0 == wReserved0) $ do { U.forM_ (gr vExt0) $ \ (!vExt, !dw) -> do { let { !w = w0 + dw}; !wReserved <- readIV vec vExt; when (wReserved == undef || w < wReserved) $ do { writeIV vec vExt w; if dw == 0 then pushFront deque (w, vExt) else pushBack deque (w, vExt)}}}}}; fix $ \ loop -> popFront deque >>= \case { Nothing -> return (); Just (!w, !vExt) -> do { step w vExt; loop}}; return $ vecIV vec};djSG :: forall i w . (Ix i, U.Unbox i, Num w, Ord w, U.Unbox w) => SparseGraph i w -> w -> U.Vector i -> IxUVector i w;djSG gr@SparseGraph{..} !undef !is0 = IxVector boundsSG $ genericDj (gr `adjW`) nVertsSG nEdgesSG undef (U.map (index boundsSG) is0);genericDj :: forall w . (U.Unbox w, Num w, Ord w) => (Int -> U.Vector (Int, w)) -> Int -> Int -> w -> U.Vector Vertex -> U.Vector w;genericDj !gr !nVerts !nEdges !undef !vs0 = U.create $ do { !dist <- UM.replicate nVerts undef; !heap <- newMinBinaryHeap (nEdges + 1); U.forM_ vs0 $ \ v -> do { UM.write dist v 0; insertBH heap (0, v)}; fix $ \ loop -> deleteFindTopBH heap >>= \case { Nothing -> return (); Just (!w1, !v1) -> do { !newVisit <- (== w1) <$> UM.read dist v1; when newVisit $ do { U.forM_ (gr v1) $ \ (!v2, !dw2) -> do { !w2 <- UM.read dist v2; let { !w2' = merge w1 dw2}; when (w2 == undef || w2' < w2) $ do { UM.write dist v2 w2'; insertBH heap (w2', v2)}}}; loop}}; return dist} where { merge :: w -> w -> w; merge = (+)};dfsPathSG :: (Unindex i) => SparseGraph i w -> i -> i -> Maybe [Vertex];dfsPathSG gr@SparseGraph{..} !sourceIx !sinkIx = runST $ do { let { !undef = -1 :: Int}; !dist <- UM.replicate nVertsSG undef; let { loop !depth !v1 !stack = do { !lastD1 <- UM.read dist v1; if lastD1 /= undef then return Nothing else do { UM.write dist v1 depth; if v1 == sink then return $ Just (v1 : stack) else do { flip fix (gr `adj` v1) $ \ visitNeighbors v2s -> case G.uncons v2s of { Nothing -> return Nothing; Just (!v2, !v2s') -> do { (<|>) <$> loop (succ depth) v2 (v1 : stack) <*> visitNeighbors v2s'}}}}}}; loop (0 :: Int) source []} where { !source = index boundsSG sourceIx; !sink = index boundsSG sinkIx};treeDfsPathSG :: (HasCallStack, Unindex i) => SparseGraph i w -> i -> i -> [Vertex];treeDfsPathSG gr@SparseGraph{..} !sourceIx !sinkIx = fromJust $ runST $ do { let { !undef = -1 :: Int}; let { loop !parent !v1 !stack = do { if v1 == sink then return $ Just (v1 : stack) else do { flip fix (U.filter (/= parent) $ gr `adj` v1) $ \ visitNeighbors v2s -> case G.uncons v2s of { Nothing -> return Nothing; Just (!v2, !v2s') -> do { (<|>) <$> loop v1 v2 (v1 : stack) <*> visitNeighbors v2s'}}}}}; loop undef source []} where { !source = index boundsSG sourceIx; !sink = index boundsSG sinkIx};createDfsTreeSG :: (Unindex i) => SparseGraph i w -> i -> U.Vector Vertex;createDfsTreeSG gr@SparseGraph{..} !sourceIx = U.create $ do { let { !undef = -1 :: Int}; !prev <- UM.replicate nVertsSG undef; !queue <- newBufferAsQueue nVertsSG; pushBack queue source; fix $ \ loop -> do { popFront queue >>= \case { Nothing -> return (); Just !v1 -> do { U.forM_ (gr `adj` v1) $ \ v2 -> do { !p <- UM.unsafeRead prev v2; when (p == undef) $ do { UM.unsafeWrite prev v2 v1; pushBack queue v2}}; loop}}}; return prev} where { !source = index boundsSG sourceIx};createBfsTreeSG :: (Unindex i) => SparseGraph i w -> i -> U.Vector Vertex;createBfsTreeSG gr@SparseGraph{..} !sourceIx = U.create $ do { let { !undef = -1 :: Int}; !prev <- UM.replicate nVertsSG undef; !queue <- newBufferAsQueue nVertsSG; pushBack queue source; fix $ \ loop -> do { popFront queue >>= \case { Nothing -> return (); Just !v1 -> do { U.forM_ (gr `adj` v1) $ \ v2 -> do { !p <- UM.unsafeRead prev v2; when (p == undef) $ do { UM.unsafeWrite prev v2 v1; pushBack queue v2}}; loop}}}; return prev} where { !source = index boundsSG sourceIx};restorePath :: U.Vector Vertex -> Vertex -> U.Vector Vertex;restorePath !toParent !sink = U.reverse $ U.unfoldr f sink where { f !v | v == (-2) = Nothing | v' == (-1) = Just (v, -2) | otherwise = Just (v, v') where { v' = toParent U.! v}};topSortSG :: SparseGraph i w -> [Vertex];topSortSG gr@SparseGraph{..} = runST $ do { !vis <- UM.replicate nVertsSG False; let { dfsM !acc !v = do { UM.unsafeRead vis v >>= \case { True -> return acc; False -> do { UM.unsafeWrite vis v True; !vs <- U.filterM (fmap not . UM.unsafeRead vis) $ gr `adj` v; (v :) <$> U.foldM' dfsM acc vs}}}}; U.foldM' dfsM [] (U.generate nVertsSG id)};revTopScc1SG :: forall i w m . (PrimMonad m) => SparseGraph i w -> UM.MVector (PrimState m) Bool -> Vertex -> m [Vertex];revTopScc1SG !gr' !vis !v0 = do { flip fix ([], v0) $ \ loop (!acc, !v) -> do { UM.unsafeRead vis v >>= \case { True -> return acc; False -> do { UM.unsafeWrite vis v True; !vs <- U.filterM (fmap not . UM.unsafeRead vis) $ gr' `adj` v; (v :) <$> U.foldM' (curry loop) acc vs}}}};revSG :: (Unindex i, U.Unbox w) => SparseGraph i w -> SparseGraph i w;revSG SparseGraph{..} = buildRawSG boundsSG edges' where { !vws = U.zip adjacentsSG edgeWeightsSG; !edges' = flip U.concatMap (U.generate nVertsSG id) $ \ v1 -> let { !o1 = U.unsafeIndex offsetsSG v1; !o2 = U.unsafeIndex offsetsSG (v1 + 1); !vw2s = U.unsafeSlice o1 (o2 - o1) vws} in U.map (\ (v2, !w2) -> (v2, v1, w2)) vw2s};revTopSccSG :: (Unindex i, U.Unbox w) => SparseGraph i w -> [[Int]];revTopSccSG gr = collectSccPreorderSG $ topSortSG gr where { !gr' = revSG gr; collectSccPreorderSG :: [Int] -> [[Int]]; collectSccPreorderSG !topVerts = runST $ do { !vis <- UM.replicate (nVertsSG gr) False; filter (not . null) <$> mapM (revTopScc1SG gr' vis) topVerts}};topSccSG :: (Unindex i, U.Unbox w) => SparseGraph i w -> [[Int]];topSccSG = map reverse . revTopSccSG;treeDepthInfoSG :: SparseGraph Int w -> Int -> (ToParent, U.Vector Int);treeDepthInfoSG gr@SparseGraph{..} !root = runST $ do { !parents <- UM.replicate nVerts (-1 :: Int); !depths <- UM.replicate nVerts (-1 :: Int); flip fix (0 :: Int, -1 :: Int, U.singleton root) $ \ loop (!depth, !parent, !vs) -> do { U.forM_ vs $ \ v -> do { UM.unsafeWrite depths v depth; UM.unsafeWrite parents v parent; let { !vs' = U.filter (/= parent) $ gr `adj` v}; loop (succ depth, v, vs')}}; (,) <$> (ToParent <$> U.unsafeFreeze parents) <*> U.unsafeFreeze depths} where { !nVerts = rangeSize boundsSG};lcaCacheSG :: SparseGraph Int w -> Vertex -> LcaCache;lcaCacheSG !gr !root = (toParent, depths, toParentN) where { (!toParent, !depths) = treeDepthInfoSG gr root; !toParentN = newBinLift toParent};foldTreeImpl :: forall m op a w . (Monad m) => SparseGraph Int w -> Vertex -> (op -> a -> a) -> (Vertex -> a) -> (a -> op) -> (Vertex -> a -> m ()) -> m a;foldTreeImpl !tree !root !sact_ !acc0At !toOp !memo = inner (-1) root where { inner :: Vertex -> Vertex -> m a; inner !parent !v1 = do { let { !acc0 = acc0At v1}; !res <- U.foldM' (\ acc v2 -> (`sact_` acc) . toOp <$> inner v1 v2) acc0 v2s; memo v1 res; return res} where { !v2s = U.filter (/= parent) $ tree `adj` v1}};foldTree :: SparseGraph Int w -> Vertex -> (op -> a -> a) -> (Vertex -> a) -> (a -> op) -> a;foldTree !tree !root !sact_ !acc0At !toOp = runIdentity $ foldTreeImpl tree root sact_ acc0At toOp (\ _ _ -> return ());scanTree :: (G.Vector v a) => SparseGraph Int w -> Vertex -> (op -> a -> a) -> (Vertex -> a) -> (a -> op) -> v a;scanTree !tree !root !sact_ !acc0At !toOp = G.create $ do { dp <- GM.unsafeNew nVerts; !_ <- foldTreeImpl tree root sact_ acc0At toOp $ \ v a -> do { GM.unsafeWrite dp v a}; return dp} where { !nVerts = rangeSize $! boundsSG tree};scanTreeU :: (U.Unbox a) => SparseGraph Int w -> Vertex -> (op -> a -> a) -> (Vertex -> a) -> (a -> op) -> U.Vector a;scanTreeU = scanTree;scanTreeV :: SparseGraph Int w -> Vertex -> (op -> a -> a) -> (Vertex -> a) -> (a -> op) -> V.Vector a;scanTreeV = scanTree;foldTreeAllSG :: forall a op w . (U.Unbox a, U.Unbox op, MonoidAction op a) => SparseGraph Int w -> (Vertex -> a) -> (a -> op) -> U.Vector a;foldTreeAllSG !tree !acc0At !toOp = let { !treeDp = scanTreeU tree root0 mact acc0At toOp; !rootDp = U.create $ do { !dp <- UM.unsafeNew nVerts; flip fix (-1, op0, root0) $ \ runRootDp (!parent, !parentOp, !v1) -> do { let { !children = U.filter (/= parent) $ tree `adj` v1}; let { !opL = U.scanl' (\ op v2 -> (op <>) . toOp $ treeDp U.! v2) op0 children}; let { !opR = U.scanr' (\ v2 op -> (<> op) . toOp $ treeDp U.! v2) op0 children}; let { !x1 = (parentOp <> U.last opL) `mact` acc0At v1}; UM.write dp v1 x1; flip U.imapM_ children $ \ !i2 !v2 -> do { let { !lrOp = (opL U.! i2) <> (opR U.! succ i2)}; let { !v1Acc = (parentOp <> lrOp) `mact` acc0At v2}; runRootDp (v1, toOp v1Acc, v2)}}; return dp}} in rootDp where { !nVerts = rangeSize $ boundsSG tree; !root0 = 0 :: Int; !op0 = mempty @op};distsNN :: (U.Unbox w, Num w, Ord w) => Int -> w -> U.Vector (Int, Int, w) -> IxUVector (Int, Int) w;distsNN !nVerts !undef !wEdges = IxVector bnd $ U.create $ do { !vec <- UM.replicate (nVerts * nVerts) undef; U.forM_ wEdges $ \ (!v1, !v2, !w) -> do { UM.write vec (index bnd (v1, v2)) w}; forM_ [0 .. nVerts - 1] $ \ k -> do { forM_ [0 .. nVerts - 1] $ \ i -> do { forM_ [0 .. nVerts - 1] $ \ j -> do { !x1 <- UM.read vec (index bnd (i, j)); !x2 <- do { !tmp1 <- UM.read vec (index bnd (i, k)); !tmp2 <- UM.read vec (index bnd (k, j)); return $! bool (tmp1 + tmp2) undef $ tmp1 == undef || tmp2 == undef}; UM.write vec (index bnd (i, j)) $! min x1 x2}}}; return vec} where { bnd :: ((Int, Int), (Int, Int)); bnd = ((0, 0), (nVerts - 1, nVerts - 1))};{-# INLINE sortMo #-};sortMo :: Int -> U.Vector (Int, Int) -> U.Vector Int;sortMo !maxL !lrs = U.modify (VAI.sortBy compareF) (G.generate (G.length lrs) id) where { !q = G.length lrs; !blockLength = max 1 . ceiling @Double $ (fromIntegral maxL / sqrt (fromIntegral q)); compareF !i1 !i2 = let { (!l1, !r1) = lrs U.! i1; (!l2, !r2) = lrs U.! i2; !b1 = l1 `div` blockLength; !b2 = l2 `div` blockLength; !res = compare b1 b2 <> bool (compare r2 r1) (compare r1 r2) (even b1)} in res};runMoG :: (PrimMonad m, U.Unbox x, G.Vector v b) => U.Vector x -> U.Vector (Int, Int) -> (a -> x -> m a) -> (a -> x -> m a) -> (a -> x -> m a) -> (a -> x -> m a) -> (a -> b) -> a -> m (v b);runMoG !xs !lrs !onInsL !onInsR !onRemL !onRemR !extract !state0 = do { !result <- GM.unsafeNew q; U.foldM'_ (step result) ((0 :: Int, -1 :: Int), state0) (sortMo maxL lrs); G.unsafeFreeze result} where { !q = G.length lrs; !maxL = U.maximum (U.map fst lrs); step result ((!l0, !r0), !s0) iLrs = do { let { (!l, !r) = lrs U.! iLrs}; !s' <- do { !s1 <- U.foldM' onInsL s0 (slice l (l0 - 1) xs); !s2 <- U.foldM' onInsR s1 (slice (r0 + 1) r xs); !s3 <- U.foldM' onRemL s2 (slice l0 (l - 1) xs); !s4 <- U.foldM' onRemR s3 (slice (r + 1) r0 xs); return s4}; GM.unsafeWrite result iLrs $! extract s'; return ((l, r), s')}};runMoPureG :: (U.Unbox x, G.Vector v b) => U.Vector x -> U.Vector (Int, Int) -> (a -> x -> a) -> (a -> x -> a) -> (a -> x -> a) -> (a -> x -> a) -> (a -> b) -> a -> v b;runMoPureG !xs !lrs !onInsL !onInsR !onRemL !onRemR !extract !state0 = runST $ do { runMoG xs lrs (return .: onInsL) (return .: onInsR) (return .: onRemL) (return .: onRemR) extract state0};runMo :: (PrimMonad m, U.Unbox x, U.Unbox b) => U.Vector x -> U.Vector (Int, Int) -> (a -> x -> m a) -> (a -> x -> m a) -> (a -> x -> m a) -> (a -> x -> m a) -> (a -> b) -> a -> m (U.Vector b);runMo = runMoG;runMoPure :: (U.Unbox x, U.Unbox b) => U.Vector x -> U.Vector (Int, Int) -> (a -> x -> a) -> (a -> x -> a) -> (a -> x -> a) -> (a -> x -> a) -> (a -> b) -> a -> U.Vector b;runMoPure = runMoPureG;simpleRunMo :: (PrimMonad m, U.Unbox x, U.Unbox a) => U.Vector x -> U.Vector (Int, Int) -> (a -> x -> m a) -> (a -> x -> m a) -> a -> m (U.Vector a);simpleRunMo !xs !lrs !onIns !onRem !state0 = runMo xs lrs onIns onIns onRem onRem id state0;simpleRunMoPure :: (U.Unbox x, U.Unbox a) => U.Vector x -> U.Vector (Int, Int) -> (a -> x -> a) -> (a -> x -> a) -> a -> U.Vector a;simpleRunMoPure !xs !lrs !onIns !onRem !state0 = runMoPure xs lrs onIns onIns onRem onRem id state0;exgcd :: (Integral a) => a -> a -> (a, a, a);exgcd a b = f $ go a b 1 0 0 1 where { go r0 r1 s0 s1 t0 t1 | r1 == 0 = (r0, s0, t0) | otherwise = go r1 r2 s1 s2 t1 t2 where { (!q, !r2) = r0 `divMod` r1; s2 = s0 - q * s1; t2 = t0 - q * t1}; f (!g, !u, !v) | g < 0 = (-g, -u, -v) | otherwise = (g, u, v)};invModGcd :: (Integral a) => a -> a -> Maybe a;invModGcd a m = case exgcd a m of { (1, na, _) -> Just na; _ -> Nothing};msbOf :: Int -> Int;msbOf !x = 63 - countLeadingZeros x;lsbOf :: Int -> Int;lsbOf = countTrailingZeros;log2 :: (FiniteBits b) => b -> Int;log2 !x = finiteBitSize x - 1 - countLeadingZeros x;log2CeilInt :: Int -> Int;log2CeilInt !x = msb + ceiling_ where { !msb = log2 x; !ceiling_ = if clearBit x msb > 0 then 1 else 0};bitCeil :: Int -> Int;bitCeil = bit . log2CeilInt;powersetM_ :: (Bits a, Num a, Monad m) => a -> (a -> m ()) -> m ();powersetM_ !is0 !act = act2 is0 where { act2 !is = do { act is; unless (is == 0) (act2 (is0 .&. (is - 1)))}};powerset :: (Bits a, Num a) => a -> [a];powerset !a = a : unfoldr f a where { f 0 = Nothing; f !x = Just . dupe $! a .&. (x - 1)};powersetU :: (Bits a, Num a, U.Unbox a) => a -> U.Vector a;powersetU !x0 = U.unfoldrExactN n f x0 where { !n = bit (popCount x0); f !x = (x, (x - 1) .&. x0)};unBitSet :: Int -> Int -> U.Vector Int;unBitSet n bits = U.filter (testBit bits) (U.generate n id);constructFor :: (U.Unbox a, U.Unbox b) => a -> U.Vector b -> (U.Vector a -> b -> a) -> U.Vector a;constructFor !x0 !input !f = U.create $ do { !vec <- UM.unsafeNew (U.length input + 1); UM.unsafeWrite vec 0 x0; flip U.imapM_ input $ \ lenS1 x -> do { !vec' <- U.take (succ lenS1) <$> U.unsafeFreeze vec; UM.unsafeWrite vec (succ lenS1) $! f vec' x}; return vec};relaxMany :: (HasCallStack, G.Vector v a, G.Vector v (Int, a), G.Vector v b) => (a -> a -> a) -> v a -> v b -> (b -> v (Int, a)) -> v a;relaxMany !relax !vec0 !input !expander = G.create $ do { !vec <- G.unsafeThaw vec0; G.forM_ input $ \ x -> do { G.forM_ (expander x) $ \ (!i, !x') -> do { GM.modify vec (`relax` x') i}}; return vec};irelaxMany :: (HasCallStack, G.Vector v a, G.Vector v (Int, a), G.Vector v b) => (a -> a -> a) -> v a -> v b -> (Int -> b -> v (Int, a)) -> v a;irelaxMany !relax !vec0 !input !expander = G.create $ do { !vec <- G.unsafeThaw vec0; G.iforM_ input $ \ ix x -> do { G.forM_ (expander ix x) $ \ (!i, !x') -> do { GM.modify vec (`relax` x') i}}; return vec};relaxMany' :: (Monoid m, U.Unbox m, U.Unbox a) => U.Vector m -> U.Vector a -> (a -> U.Vector (Int, m)) -> U.Vector m;relaxMany' !vec0 !input !expander = U.create $ do { !vec <- U.unsafeThaw vec0; U.forM_ input $ \ x -> do { U.forM_ (expander x) $ \ (!i, !x') -> do { UM.modify vec (<> x') i}}; return vec};{-# INLINE pushBasedConstructN #-};pushBasedConstructN :: (HasCallStack, G.Vector v a, G.Vector v (Int, a)) => (a -> a -> a) -> v a -> (Int -> v a -> v (Int, a)) -> v a;pushBasedConstructN !relax !vec0 !expander = G.create $ do { !vec <- G.unsafeThaw vec0; forM_ [0 .. GM.length vec - 1] $ \ iFrom -> do { !freezed <- G.unsafeFreeze (GM.take (iFrom + 1) vec); G.forM_ (expander iFrom freezed) $ \ (!iTo, !x') -> do { GM.modify vec (`relax` x') iTo}}; return vec};spansU :: Int -> Int -> U.Vector ((Int, Int), (Int, Int));spansU !l !r = U.map (\ len -> ((l, l + len - 1), (l + len, r))) $ rangeU 1 (r - l);iwiSpansU :: Int -> Int -> U.Vector ((Int, Int), (Int, Int));iwiSpansU !l !r = U.map (\ len -> ((l, l + len - 1), (l + len + 1, r))) $ rangeU 0 (r - l);iwiSpansU' :: Int -> Int -> U.Vector ((Int, Int), Int, (Int, Int));iwiSpansU' !l !r = U.map (\ len -> ((l, l + len - 1), l + len, (l + len + 1, r))) $ rangeU 0 (r - l);spanDP :: (U.Unbox a) => Int -> a -> (Int -> a) -> (IxVector (Int, Int) (U.Vector a) -> (Int, Int) -> a) -> IxVector (Int, Int) (U.Vector a);spanDP !n !undef !onOne !f = constructIV ((0, 0), (n + 1, n)) $ \ vec (!spanLen, !spanL) -> if spanLen == 0 || spanL >= (n + 1 - spanLen) then undef else if spanLen == 1 then onOne spanL else f vec (spanLen, spanL);tspDP :: Int -> IxUVector (Int, Int) Int -> U.Vector Int;tspDP !nVerts !gr = U.constructN (nSets * nVerts) $ \ vec -> case G.length vec `divMod` nVerts of { (!s, !vTo) | s == bit vTo -> 0 :: Int; (!s, !vTo) | not (testBit s vTo) -> undef; (!s, !vTo) -> let { !s' = clearBit s vTo; !candidates = (U.take nVerts . U.drop (nVerts * s')) vec} in U.maximum $ flip U.imap candidates $ \ vFrom w0 -> let { !dw = gr @! (vFrom, vTo)} in bool (w0 + dw) undef (dw == undef || w0 == undef)} where { !nSets = bit nVerts; !undef = -1 :: Int};enumerateBitSets :: Int -> [[Int]];enumerateBitSets !n = inner [[]] [] (bit n - 1) where { inner :: [[Int]] -> [Int] -> Int -> [[Int]]; inner !results !acc 0 = acc : results; inner !results !acc !rest = U.foldl' step results (powersetU rest') where { !lsb = countTrailingZeros rest; !rest' = clearBit rest lsb; step !res !set = let { !set' = set .|. bit lsb} in inner res (set' : acc) (rest' .&. complement set')}};lisOf :: (HasCallStack) => U.Vector Int -> Int;lisOf !xs = runST $ do { !stree <- newSTreeU max (G.length xs) (0 :: Int); U.forM_ xs $ \ x -> do { !n0 <- fromMaybe 0 <$> querySTree stree 0 (x - 1); insertSTree stree x (n0 + 1)}; fromJust <$> querySTree stree 0 (G.length xs - 1)};lcsOf :: BS.ByteString -> BS.ByteString -> Int;lcsOf !s !t = U.last . vecIV . constructIV bnd $ \ sofar i -> case i of { (0, 0) -> 0 :: Int; (0, _) -> 0 :: Int; (_, 0) -> 0 :: Int; (!ls, !lt) -> n1 `max` n2 `max` n3 where { n1 = sofar @! (ls - 1, lt); n2 = sofar @! (ls, lt - 1); n3 | BS.index s (ls - 1) == BS.index t (lt - 1) = sofar @! (ls - 1, lt - 1) + 1 | otherwise = 0}} where { bnd = ((0, 0), (BS.length s, BS.length t))};addMod, subMod, mulMod :: Int -> Int -> Int -> Int;addMod !x !a !modulo = (x + a) `mod` modulo;subMod !x !s !modulo = (x - s) `mod` modulo;mulMod !b !p !modulo = (b * p) `mod` modulo;factMod :: Int -> Int -> Int;factMod 0 _ = 1; factMod 1 _ = 1; factMod !n !m = n * factMod (n - 1) m `rem` m;powModConst :: Int -> Int -> Int -> Int;powModConst !base !power !modulo = powModByCache power (powModCache (base `mod` modulo) modulo);invModF :: Int -> Int -> Int;invModF !d !modulo = invModFC modulo (powModCache d modulo);divModF :: Int -> Int -> Int -> Int;divModF !x !d !modulo = divModFC x (powModCache d modulo) `rem` modulo;powModCache :: Int -> Int -> (Int, U.Vector Int);powModCache !base !modulo = (modulo, doubling) where { doubling = newDoubling base (\ x -> x * x `rem` modulo)};powModByCache :: Int -> (Int, U.Vector Int) -> Int;powModByCache !power (!modulo, !cache) = foldl' step 1 [0 .. 62] where { step !acc !nBit = if testBit power nBit then acc * (cache U.! nBit) `rem` modulo else acc};invModFC :: Int -> (Int, U.Vector Int) -> Int;invModFC !primeModulo = powModByCache (primeModulo - 2);divModFC :: Int -> (Int, U.Vector Int) -> Int;divModFC !x context@(!modulo, !_) = x * invModFC modulo context `rem` modulo;factMods :: Int -> Int -> U.Vector Int;factMods !n !modulo = U.scanl' (\ !x !y -> x * y `rem` modulo) (1 :: Int) $ U.fromList [(1 :: Int) .. n];bcMod :: Int -> Int -> Int -> Int;bcMod !n !r !modulo = foldl' (\ !x !y -> divModF x y modulo) (facts U.! n) [facts U.! r, facts U.! (n - r)] where { facts = factMods n modulo};prevPermutationVec :: (Ord e, G.Vector v e, G.Vector v (Down e)) => v e -> v e;prevPermutationVec = G.map (\case { Down !x -> x}) . G.modify (void . GM.nextPermutation) . G.map Down;dictOrderModuloVec :: (HasCallStack, G.Vector v Int) => v Int -> Int -> Int;dictOrderModuloVec xs modulo = runST $ do { !stree <- newSTreeU (+) (G.length xs + 1) (0 :: Int); let { !facts = factMods (G.length xs) modulo}; !counts <- flip G.imapM xs $ \ i x -> do { !nUsed <- fromJust <$> querySTree stree 0 x; let { !nUnused = x - nUsed}; let { !factMod = facts G.! (G.length xs - (i + 1))}; let { !inc = nUnused * factMod `rem` modulo}; insertSTree stree x 1; return inc}; return $! succ $! G.foldl1' (\ !acc x -> (acc + x) `rem` modulo) counts};class TypeInt a where { typeInt :: Proxy a -> Int};newtype ModInt p = ModInt{getModInt :: Int} deriving (Eq, P.Prim)                                            deriving newtype (Ord, Read, Show, Real);instance (TypeInt p) => Num (ModInt p) where { (ModInt !x1) + (ModInt !x2) = ModInt $! (x1 + x2) `mod` typeInt (Proxy @p); (ModInt !x1) * (ModInt !x2) = ModInt $! (x1 * x2) `mod` typeInt (Proxy @p); negate (ModInt !v) = ModInt $ (-v) `mod` typeInt (Proxy @p); abs = id; signum _ = 1; fromInteger = ModInt . fromInteger};instance (TypeInt p) => Fractional (ModInt p) where { recip (ModInt !x) = ModInt $! invModF x (typeInt (Proxy @p)); fromRational !r = ModInt n / ModInt d where { n = fromInteger $! Ratio.numerator r; d = fromInteger $! Ratio.denominator r}};instance (TypeInt p) => Enum (ModInt p) where { toEnum = ModInt . (`mod` typeInt (Proxy @p)); fromEnum = coerce};instance (TypeInt p) => SemigroupAction (Product (ModInt p)) (ModInt p) where { sact (Product !x1) !x2 = x1 * x2};newtype instance  U.MVector s (ModInt p) = MV_ModInt (P.MVector s (ModInt p));newtype instance  U.Vector (ModInt p) = V_ModInt (P.Vector (ModInt p));deriving via (U.UnboxViaPrim (ModInt p)) instance GM.MVector UM.MVector (ModInt p);deriving via (U.UnboxViaPrim (ModInt p)) instance G.Vector U.Vector (ModInt p);instance U.Unbox (ModInt p);data RollingHash b p = RollingHash{sourceLength :: !Int, dimensions :: !(U.Vector Int), hashSum :: !(U.Vector Int)} deriving (Show, Eq);data HashInt = HashInt;instance TypeInt HashInt where { typeInt _ = 100};newRH :: forall p . (TypeInt p) => String -> RollingHash HashInt p;newRH !source = RollingHash n bn hashSum_ where { !p = typeInt (Proxy @p); !b = typeInt (Proxy @HashInt); !n = length source; !bn = U.iterateN (succ n) (\ lastB -> b * lastB `mod` p) (1 :: Int); !hashSum_ = evalState (U.mapM (\ !ch -> state $ \ !acc -> f ch acc) $ U.fromList source) (0 :: Int) where { f :: Char -> Int -> (Int, Int); f !ch !lastX = dupe $! (lastX * b + ord ch) `mod` p}};lengthRH :: RollingHash b p -> Int;lengthRH (RollingHash !len !_ !_) = len;data HashSlice p = HashSlice{hashValue :: {-# UNPACK #-} !Int, hashLength :: {-# UNPACK #-} !Int} deriving (Show, Eq);sliceRH :: forall b p . (TypeInt p) => RollingHash b p -> Int -> Int -> HashSlice p;sliceRH (RollingHash !_ !bn !s) !i0 !i1 | i0 > i1 = emptyHS | otherwise = let { !len = i1 - i0 + 1; !s1 = s U.! i1; !s0 = fromMaybe 0 $ s U.!? pred i0; !value = (s1 - (bn U.! len) * s0) `mod` p} in HashSlice value len where { !p = typeInt (Proxy @p)};consHS :: forall b p . (TypeInt p) => RollingHash b p -> HashSlice p -> HashSlice p -> HashSlice p;consHS (RollingHash !_ !bn !_) (HashSlice !v0 !l0) (HashSlice !v1 !l1) = HashSlice value len where { !p = typeInt (Proxy @p); !value = ((bn U.! l1) * v0 + v1) `mod` p; !len = l0 + l1};emptyHS :: HashSlice p;emptyHS = HashSlice 0 0;concatHS :: forall b p t . (TypeInt p, Foldable t) => RollingHash b p -> t (HashSlice p) -> HashSlice p;concatHS !rhash !slices = foldl' (consHS rhash) emptyHS slices;mulMatToCol :: (Num e, IArray UArray e) => UArray (Int, Int) e -> [e] -> [e];mulMatToCol !mat !col = let { !rows = chunksOf n (elems mat)} in map (sum . zipWith (*) col) rows where { !n = length col; !_ = dbgAssert $ (== n) . succ . fst . snd $ bounds mat};mulMatToColMod :: UArray (Int, Int) Int -> Int -> [Int] -> [Int];mulMatToColMod !mat !modulus !col = let { !rows = chunksOf n (elems mat)} in map (foldl1' ((`mod` modulus) .: (+)) . zipWith (*) col) rows where { !n = length col; !_ = dbgAssert $ (== n) . succ . fst . snd $ bounds mat};mulMat :: (Num e, IArray UArray e) => UArray (Int, Int) e -> UArray (Int, Int) e -> UArray (Int, Int) e;mulMat !a !b = listArray @UArray ((i0, k0), (ix, kx)) [sum [a ! (i, j) * b ! (j', k) | (j, j') <- zip (range (j0, jx)) (range (j'0, j'x))] | i <- range (i0, ix), k <- range (k0, kx)] where { ((!i0, !j0), (!ix, !jx)) = bounds a; ((!j'0, !k0), (!j'x, !kx)) = bounds b; !_ = dbgAssert (jx - j0 == j'x - j'0)};mulMatMod :: Int -> UArray (Int, Int) Int -> UArray (Int, Int) Int -> UArray (Int, Int) Int;mulMatMod m a b = listArray @UArray ((i0, k0), (ix, kx)) [sum [a ! (i, j) * b ! (j', k) `mod` m | (j, j') <- zip (range (j0, jx)) (range (j'0, j'x))] `mod` m | i <- range (i0, ix), k <- range (k0, kx)] where { ((!i0, !j0), (!ix, !jx)) = bounds a; ((!j'0, !k0), (!j'x, !kx)) = bounds b; !_ = dbgAssert (jx - j0 == j'x - j'0)};unitMat :: Int -> UArray (Int, Int) Int;unitMat !n = accumArray @UArray (+) (0 :: Int) ((0, 0), (pred n, pred n)) $ map ((, 1) . dupe) [0 .. pred n];newtype MulMatMod p = MulMatMod (UArray (Int, Int) Int) deriving (Eq, Show);instance forall p . (TypeInt p) => Semigroup (MulMatMod p) where { (MulMatMod !m1) <> (MulMatMod !m2) = MulMatMod $ mulMatMod (typeInt (Proxy @p)) m1 m2};instance (TypeInt p) => SemigroupAction (MulMatMod p) [Int] where { sact (MulMatMod !mat) !col = mulMatToColMod mat (typeInt (Proxy @p)) col};rot45 :: (Int, Int) -> (Int, Int);rot45 (!x, !y) = (x - y, x + y);mDigitsRev :: (Integral n) => n -> n -> Maybe [n];mDigitsRev !base !i = if base < 1 then Nothing else Just $ dr base i where { dr _ 0 = []; dr !b !x = case base of { 1 -> genericTake x $ repeat 1; _ -> let { (!rest, !lastDigit) = quotRem x b} in lastDigit : dr b rest}};mDigits :: (Integral n) => n -> n -> Maybe [n];mDigits !base !i = reverse <$> mDigitsRev base i;digitsRev :: (Integral n) => n -> n -> [n];digitsRev !base = fromJust . mDigitsRev base;digits :: (Integral n) => n -> n -> [n];digits _ 0 = [0]; digits !base !x = reverse $ digitsRev base x;unDigits :: (Integral n) => n -> [n] -> n;unDigits !base = foldl' (\ !a !b -> a * base + b) 0;convertBase :: (Integral a) => a -> a -> [a] -> [a];convertBase !from !to = digits to . unDigits from;toDigitsU :: Int -> Int -> U.Vector Int;toDigitsU !base !x0 | x0 < base = U.singleton x0 | otherwise = U.unfoldr expand x0 where { expand 0 = Nothing; expand x = Just $ swap (x `divMod` base)};toNDigitsU :: Int -> Int -> Int -> U.Vector Int;toNDigitsU !base !nDigits !x0 = U.unfoldrExactN nDigits expand x0 where { expand x = swap (x `divMod` base)};unDigitsU :: Int -> U.Vector Int -> Int;unDigitsU !base !xs = fst $ U.foldl' step (0 :: Int, 1 :: Int) xs where { step (!acc, !d) !i = (acc + d * i, base * d)};primes :: [Int];primes = 2 : 3 : minus [5, 7 ..] (unionAll [[p * p, p * p + 2 * p ..] | p <- tail primes]) where { minus (x : xs) (y : ys) = case compare x y of { LT -> x : minus xs (y : ys); EQ -> minus xs ys; GT -> minus (x : xs) ys}; minus xs _ = xs; union (x : xs) (y : ys) = case compare x y of { LT -> x : union xs (y : ys); EQ -> x : union xs ys; GT -> y : union (x : xs) ys}; union xs [] = xs; union [] ys = ys; unionAll :: (Ord a) => [[a]] -> [a]; unionAll ((x : xs) : t) = x : union xs (unionAll $ pairs t) where { pairs ((x : xs) : (ys : t)) = (x : union xs ys) : pairs t; pairs _ = error "unionAll _ pairs: unreachable"}; unionAll _ = error "unionAll: unreachable"};primeFactors :: Int -> [(Int, Int)];primeFactors !n_ = map (\ !xs -> (head xs, length xs)) . group $ inner n_ input where { input = 2 : 3 : [y | x <- [5, 11 ..], y <- [x, x + 2]]; inner n pps@(p : ps) | n == 1 = [] | n < p * p = [n] | r == 0 = p : inner q pps | otherwise = inner n ps where { (q, r) = divMod n p}; inner _ _ = error "unreachable"};divisorsOf :: Int -> [Int];divisorsOf n = sort $ inner 1 where { inner k | k * k > n = [] | k * k == n = [k] | r == 0 = k : d : inner (succ k) | otherwise = inner (succ k) where { (!d, !r) = n `divMod` k}}
{- ORMOLU_ENABLE -}
-- }}}

createBuffer :: (U.Unbox a) => (forall s. ST s (Buffer s a)) -> U.Vector a
createBuffer f = runST $ do
  !buf <- f
  unsafeFreezeBuffer buf

main :: IO ()
main = do
  (!n, !d) <- ints2
  !xys <- U.replicateM n ints2

  let constraints = createBuffer $ do
        !buf <- newBuffer (4 * n * pred n)
        forM_ [0 .. n - 1] $ \v1 -> do
          let (!x1, !y1) = xys U.! v1
          let !v1' = v1 + n
          forM_ [v1 + 1 .. n - 1] $ \v2 -> do
            let (!x2, !y2) = xys U.! v2
            let !v2' = v2 + n

            -- not v1 || not v2 \iff v1 => not v2, v2 => not v1
            when (abs (x1 - x2) < d) $ do
              pushBacks buf $ U.fromListN 2 [(v1, v2'), (v2, v1')]

            -- v1 || v2 \iff not v1 => v2, not v2 => v1
            when (abs (y1 - y2) < d) $ do
              pushBacks buf $ U.fromListN 2 [(v1', v2), (v2', v1)]

            -- not v1 || v2 \iff v1 => v2, not v2 => not v1
            when (abs (x1 - y2) < d) $ do
              pushBacks buf $ U.fromListN 2 [(v1, v2), (v2', v1')]

            -- v1 || v2 \iff not v1 => v2, not v2 => v1
            when (abs (y1 - x2) < d) $ do
              pushBacks buf $ U.fromListN 2 [(v1', v2), (v2', v1)]

        return buf

  let gr = buildSG (0, 2 * n - 1) constraints
  let !sccs = revTopSccSG gr

  let !groups = U.create $ do
        !vec <- UM.replicate (2 * n) (-1 :: Int)
        forM_ (zip [0 :: Int ..] sccs) $ \(!iScc, !scc) -> do
          forM_ scc $ \v -> do
            UM.write vec v iScc
        return vec

  let !saturatable = U.all (\x -> groups U.! x /= groups U.! (x + n)) (U.generate n id)
  if saturatable
    then do
      putStrLn "Yes"

      let !res = U.map (== 1) $ U.create $ do
            !vec <- UM.replicate n (-1 :: Int)
            forM_ sccs $ \scc -> do
              forM_ scc $ \v -> do
                !prev <- UM.read vec (v `mod` n)
                when (prev == -1) $ do
                  -- NOTE: We're seeing from the downstream vertices
                  UM.write vec (v `mod` n) $ bool 1 0 (v < n)
            return vec

      (\f -> U.zipWithM_ f xys res) $ \(!x, !y) b ->
        print $ bool y x b

    else do
      putStrLn "No"

